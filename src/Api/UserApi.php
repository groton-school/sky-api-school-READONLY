<?php
/**
 * UserApi
 * PHP version 7.4
 *
 * @category Class
 * @package  SKY\School
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * School
 *
 * This API is used to provide access to school information such as users, academics, admissions, athletics, content, lists, and general school info.
 *
 * The version of the OpenAPI document: 1.0
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.4.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace SKY\School\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use SKY\School\ApiException;
use SKY\School\Configuration;
use SKY\School\HeaderSelector;
use SKY\School\ObjectSerializer;

/**
 * UserApi Class Doc Comment
 *
 * @category Class
 * @package  SKY\School
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class UserApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'v1UsersAddresstypesGet' => [
            'application/json',
        ],
        'v1UsersAuditGet' => [
            'application/json',
        ],
        'v1UsersBbidstatusGet' => [
            'application/json',
        ],
        'v1UsersByParentIdStudentsGet' => [
            'application/json',
        ],
        'v1UsersByUserIdAddressesByAddressIdByAddressTypeIdDelete' => [
            'application/json',
        ],
        'v1UsersByUserIdAddressesByAddressIdPatch' => [
            'application/json',
        ],
        'v1UsersByUserIdAddressesGet' => [
            'application/json',
        ],
        'v1UsersByUserIdAddressesPost' => [
            'application/json',
        ],
        'v1UsersByUserIdAddressesSharePost' => [
            'application/json',
        ],
        'v1UsersByUserIdCustomfieldsGet' => [
            'application/json',
        ],
        'v1UsersByUserIdCustomfieldsListPatch' => [
            'application/json',
        ],
        'v1UsersByUserIdCustomfieldsListPost' => [
            'application/json',
        ],
        'v1UsersByUserIdCustomfieldsPatch' => [
            'application/json',
        ],
        'v1UsersByUserIdCustomfieldsPost' => [
            'application/json',
        ],
        'v1UsersByUserIdEducationByEducationIdDelete' => [
            'application/json',
        ],
        'v1UsersByUserIdEducationByEducationIdPatch' => [
            'application/json',
        ],
        'v1UsersByUserIdEducationGet' => [
            'application/json',
        ],
        'v1UsersByUserIdEducationPost' => [
            'application/json',
        ],
        'v1UsersByUserIdEmergencycontactsGet' => [
            'application/json',
        ],
        'v1UsersByUserIdEmergencycontactsNonuserPost' => [
            'application/json',
        ],
        'v1UsersByUserIdEmergencycontactsUserPost' => [
            'application/json',
        ],
        'v1UsersByUserIdEmploymentGet' => [
            'application/json',
        ],
        'v1UsersByUserIdGet' => [
            'application/json',
        ],
        'v1UsersByUserIdOccupationsByOccupationIdDelete' => [
            'application/json',
        ],
        'v1UsersByUserIdOccupationsByOccupationIdPatch' => [
            'application/json',
        ],
        'v1UsersByUserIdOccupationsGet' => [
            'application/json',
        ],
        'v1UsersByUserIdOccupationsPost' => [
            'application/json',
        ],
        'v1UsersByUserIdPhonesByPhoneIdByPhoneTypeIdDelete' => [
            'application/json',
        ],
        'v1UsersByUserIdPhonesByPhoneIdPatch' => [
            'application/json',
        ],
        'v1UsersByUserIdPhonesGet' => [
            'application/json',
        ],
        'v1UsersByUserIdPhonesPost' => [
            'application/json',
        ],
        'v1UsersByUserIdPhonesSharePost' => [
            'application/json',
        ],
        'v1UsersByUserIdRelationshipsDelete' => [
            'application/json',
        ],
        'v1UsersByUserIdRelationshipsGet' => [
            'application/json',
        ],
        'v1UsersByUserIdRelationshipsPost' => [
            'application/json',
        ],
        'v1UsersChangedGet' => [
            'application/json',
        ],
        'v1UsersCustomfieldsGet' => [
            'application/json',
        ],
        'v1UsersEmergencycontactsChangedGet' => [
            'application/json',
        ],
        'v1UsersEnrollPost' => [
            'application/json',
        ],
        'v1UsersEnrollmentsGet' => [
            'application/json',
        ],
        'v1UsersExtendedByUserIdGet' => [
            'application/json',
        ],
        'v1UsersExtendedGet' => [
            'application/json',
        ],
        'v1UsersGendertypesGet' => [
            'application/json',
        ],
        'v1UsersMeGet' => [
            'application/json',
        ],
        'v1UsersPatch' => [
            'application/json',
        ],
        'v1UsersPhonetypesGet' => [
            'application/json',
        ],
        'v1UsersPost' => [
            'application/json',
        ],
        'v1usersget' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation v1UsersAddresstypesGet
     *
     * Users address types
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersAddresstypesGet'] to see the possible values for this operation
     *
     * @throws \SKY\School\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \SKY\School\Model\AddressTypeCollection
     */
    public function v1UsersAddresstypesGet(string $contentType = self::contentTypes['v1UsersAddresstypesGet'][0])
    {
        [$response] = $this->v1UsersAddresstypesGetWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation v1UsersAddresstypesGetWithHttpInfo
     *
     * Users address types
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersAddresstypesGet'] to see the possible values for this operation
     *
     * @throws \SKY\School\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \SKY\School\Model\AddressTypeCollection, HTTP status code, HTTP response headers (array of strings)
     */
    public function v1UsersAddresstypesGetWithHttpInfo(string $contentType = self::contentTypes['v1UsersAddresstypesGet'][0])
    {
        $request = $this->v1UsersAddresstypesGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SKY\School\Model\AddressTypeCollection' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SKY\School\Model\AddressTypeCollection' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SKY\School\Model\AddressTypeCollection', []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = '\SKY\School\Model\AddressTypeCollection';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SKY\School\Model\AddressTypeCollection',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v1UsersAddresstypesGetAsync
     *
     * Users address types
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersAddresstypesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1UsersAddresstypesGetAsync(string $contentType = self::contentTypes['v1UsersAddresstypesGet'][0])
    {
        return $this->v1UsersAddresstypesGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v1UsersAddresstypesGetAsyncWithHttpInfo
     *
     * Users address types
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersAddresstypesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1UsersAddresstypesGetAsyncWithHttpInfo(string $contentType = self::contentTypes['v1UsersAddresstypesGet'][0])
    {
        $returnType = '\SKY\School\Model\AddressTypeCollection';
        $request = $this->v1UsersAddresstypesGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v1UsersAddresstypesGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersAddresstypesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v1UsersAddresstypesGetRequest(string $contentType = self::contentTypes['v1UsersAddresstypesGet'][0])
    {


        $resourcePath = '/v1/users/addresstypes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v1UsersAuditGet
     *
     * Users audit by role ID
     *
     * @param  string $roleId Role to return audit information for. (required)
     * @param  \DateTime $startDate Format - date-time (as date-time in RFC3339). The date to begin looking for changes. Must be greater than 01/01/1990. (optional)
     * @param  \DateTime $endDate Format - date-time (as date-time in RFC3339). The date to end looking for changes.  Must be within 1 year of start_date. Null returns start_date + 7 days. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersAuditGet'] to see the possible values for this operation
     *
     * @throws \SKY\School\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \SKY\School\Model\UserAuditReadCollection
     */
    public function v1UsersAuditGet($roleId, $startDate = null, $endDate = null, string $contentType = self::contentTypes['v1UsersAuditGet'][0])
    {
        [$response] = $this->v1UsersAuditGetWithHttpInfo($roleId, $startDate, $endDate, $contentType);
        return $response;
    }

    /**
     * Operation v1UsersAuditGetWithHttpInfo
     *
     * Users audit by role ID
     *
     * @param  string $roleId Role to return audit information for. (required)
     * @param  \DateTime $startDate Format - date-time (as date-time in RFC3339). The date to begin looking for changes. Must be greater than 01/01/1990. (optional)
     * @param  \DateTime $endDate Format - date-time (as date-time in RFC3339). The date to end looking for changes.  Must be within 1 year of start_date. Null returns start_date + 7 days. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersAuditGet'] to see the possible values for this operation
     *
     * @throws \SKY\School\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \SKY\School\Model\UserAuditReadCollection, HTTP status code, HTTP response headers (array of strings)
     */
    public function v1UsersAuditGetWithHttpInfo($roleId, $startDate = null, $endDate = null, string $contentType = self::contentTypes['v1UsersAuditGet'][0])
    {
        $request = $this->v1UsersAuditGetRequest($roleId, $startDate, $endDate, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SKY\School\Model\UserAuditReadCollection' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SKY\School\Model\UserAuditReadCollection' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SKY\School\Model\UserAuditReadCollection', []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = '\SKY\School\Model\UserAuditReadCollection';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SKY\School\Model\UserAuditReadCollection',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v1UsersAuditGetAsync
     *
     * Users audit by role ID
     *
     * @param  string $roleId Role to return audit information for. (required)
     * @param  \DateTime $startDate Format - date-time (as date-time in RFC3339). The date to begin looking for changes. Must be greater than 01/01/1990. (optional)
     * @param  \DateTime $endDate Format - date-time (as date-time in RFC3339). The date to end looking for changes.  Must be within 1 year of start_date. Null returns start_date + 7 days. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersAuditGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1UsersAuditGetAsync($roleId, $startDate = null, $endDate = null, string $contentType = self::contentTypes['v1UsersAuditGet'][0])
    {
        return $this->v1UsersAuditGetAsyncWithHttpInfo($roleId, $startDate, $endDate, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v1UsersAuditGetAsyncWithHttpInfo
     *
     * Users audit by role ID
     *
     * @param  string $roleId Role to return audit information for. (required)
     * @param  \DateTime $startDate Format - date-time (as date-time in RFC3339). The date to begin looking for changes. Must be greater than 01/01/1990. (optional)
     * @param  \DateTime $endDate Format - date-time (as date-time in RFC3339). The date to end looking for changes.  Must be within 1 year of start_date. Null returns start_date + 7 days. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersAuditGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1UsersAuditGetAsyncWithHttpInfo($roleId, $startDate = null, $endDate = null, string $contentType = self::contentTypes['v1UsersAuditGet'][0])
    {
        $returnType = '\SKY\School\Model\UserAuditReadCollection';
        $request = $this->v1UsersAuditGetRequest($roleId, $startDate, $endDate, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v1UsersAuditGet'
     *
     * @param  string $roleId Role to return audit information for. (required)
     * @param  \DateTime $startDate Format - date-time (as date-time in RFC3339). The date to begin looking for changes. Must be greater than 01/01/1990. (optional)
     * @param  \DateTime $endDate Format - date-time (as date-time in RFC3339). The date to end looking for changes.  Must be within 1 year of start_date. Null returns start_date + 7 days. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersAuditGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v1UsersAuditGetRequest($roleId, $startDate = null, $endDate = null, string $contentType = self::contentTypes['v1UsersAuditGet'][0])
    {

        // verify the required parameter 'roleId' is set
        if ($roleId === null || (is_array($roleId) && count($roleId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $roleId when calling v1UsersAuditGet'
            );
        }




        $resourcePath = '/v1/users/audit';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $roleId,
            'role_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $startDate,
            'start_date', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $endDate,
            'end_date', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v1UsersBbidstatusGet
     *
     * Users BBID status by role(s).
     *
     * @param  string $baseRoleIds Comma delimited list of base role IDs to get users for. (required)
     * @param  int $marker Format - int32. The user&#39;s ID to start at to return the next batch of data. Results will start with the next user in the result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersBbidstatusGet'] to see the possible values for this operation
     *
     * @throws \SKY\School\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \SKY\School\Model\SchoolBbidStatusCollection
     */
    public function v1UsersBbidstatusGet($baseRoleIds, $marker = null, string $contentType = self::contentTypes['v1UsersBbidstatusGet'][0])
    {
        [$response] = $this->v1UsersBbidstatusGetWithHttpInfo($baseRoleIds, $marker, $contentType);
        return $response;
    }

    /**
     * Operation v1UsersBbidstatusGetWithHttpInfo
     *
     * Users BBID status by role(s).
     *
     * @param  string $baseRoleIds Comma delimited list of base role IDs to get users for. (required)
     * @param  int $marker Format - int32. The user&#39;s ID to start at to return the next batch of data. Results will start with the next user in the result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersBbidstatusGet'] to see the possible values for this operation
     *
     * @throws \SKY\School\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \SKY\School\Model\SchoolBbidStatusCollection, HTTP status code, HTTP response headers (array of strings)
     */
    public function v1UsersBbidstatusGetWithHttpInfo($baseRoleIds, $marker = null, string $contentType = self::contentTypes['v1UsersBbidstatusGet'][0])
    {
        $request = $this->v1UsersBbidstatusGetRequest($baseRoleIds, $marker, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SKY\School\Model\SchoolBbidStatusCollection' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SKY\School\Model\SchoolBbidStatusCollection' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SKY\School\Model\SchoolBbidStatusCollection', []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = '\SKY\School\Model\SchoolBbidStatusCollection';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SKY\School\Model\SchoolBbidStatusCollection',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v1UsersBbidstatusGetAsync
     *
     * Users BBID status by role(s).
     *
     * @param  string $baseRoleIds Comma delimited list of base role IDs to get users for. (required)
     * @param  int $marker Format - int32. The user&#39;s ID to start at to return the next batch of data. Results will start with the next user in the result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersBbidstatusGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1UsersBbidstatusGetAsync($baseRoleIds, $marker = null, string $contentType = self::contentTypes['v1UsersBbidstatusGet'][0])
    {
        return $this->v1UsersBbidstatusGetAsyncWithHttpInfo($baseRoleIds, $marker, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v1UsersBbidstatusGetAsyncWithHttpInfo
     *
     * Users BBID status by role(s).
     *
     * @param  string $baseRoleIds Comma delimited list of base role IDs to get users for. (required)
     * @param  int $marker Format - int32. The user&#39;s ID to start at to return the next batch of data. Results will start with the next user in the result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersBbidstatusGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1UsersBbidstatusGetAsyncWithHttpInfo($baseRoleIds, $marker = null, string $contentType = self::contentTypes['v1UsersBbidstatusGet'][0])
    {
        $returnType = '\SKY\School\Model\SchoolBbidStatusCollection';
        $request = $this->v1UsersBbidstatusGetRequest($baseRoleIds, $marker, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v1UsersBbidstatusGet'
     *
     * @param  string $baseRoleIds Comma delimited list of base role IDs to get users for. (required)
     * @param  int $marker Format - int32. The user&#39;s ID to start at to return the next batch of data. Results will start with the next user in the result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersBbidstatusGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v1UsersBbidstatusGetRequest($baseRoleIds, $marker = null, string $contentType = self::contentTypes['v1UsersBbidstatusGet'][0])
    {

        // verify the required parameter 'baseRoleIds' is set
        if ($baseRoleIds === null || (is_array($baseRoleIds) && count($baseRoleIds) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $baseRoleIds when calling v1UsersBbidstatusGet'
            );
        }



        $resourcePath = '/v1/users/bbidstatus';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $baseRoleIds,
            'base_role_ids', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $marker,
            'marker', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v1UsersByParentIdStudentsGet
     *
     * Users Children of Parent
     *
     * @param  int $parentId Format - int32. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByParentIdStudentsGet'] to see the possible values for this operation
     *
     * @throws \SKY\School\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \SKY\School\Model\ChildOfParentCollection
     */
    public function v1UsersByParentIdStudentsGet($parentId, string $contentType = self::contentTypes['v1UsersByParentIdStudentsGet'][0])
    {
        [$response] = $this->v1UsersByParentIdStudentsGetWithHttpInfo($parentId, $contentType);
        return $response;
    }

    /**
     * Operation v1UsersByParentIdStudentsGetWithHttpInfo
     *
     * Users Children of Parent
     *
     * @param  int $parentId Format - int32. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByParentIdStudentsGet'] to see the possible values for this operation
     *
     * @throws \SKY\School\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \SKY\School\Model\ChildOfParentCollection, HTTP status code, HTTP response headers (array of strings)
     */
    public function v1UsersByParentIdStudentsGetWithHttpInfo($parentId, string $contentType = self::contentTypes['v1UsersByParentIdStudentsGet'][0])
    {
        $request = $this->v1UsersByParentIdStudentsGetRequest($parentId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SKY\School\Model\ChildOfParentCollection' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SKY\School\Model\ChildOfParentCollection' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SKY\School\Model\ChildOfParentCollection', []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = '\SKY\School\Model\ChildOfParentCollection';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SKY\School\Model\ChildOfParentCollection',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v1UsersByParentIdStudentsGetAsync
     *
     * Users Children of Parent
     *
     * @param  int $parentId Format - int32. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByParentIdStudentsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1UsersByParentIdStudentsGetAsync($parentId, string $contentType = self::contentTypes['v1UsersByParentIdStudentsGet'][0])
    {
        return $this->v1UsersByParentIdStudentsGetAsyncWithHttpInfo($parentId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v1UsersByParentIdStudentsGetAsyncWithHttpInfo
     *
     * Users Children of Parent
     *
     * @param  int $parentId Format - int32. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByParentIdStudentsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1UsersByParentIdStudentsGetAsyncWithHttpInfo($parentId, string $contentType = self::contentTypes['v1UsersByParentIdStudentsGet'][0])
    {
        $returnType = '\SKY\School\Model\ChildOfParentCollection';
        $request = $this->v1UsersByParentIdStudentsGetRequest($parentId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v1UsersByParentIdStudentsGet'
     *
     * @param  int $parentId Format - int32. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByParentIdStudentsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v1UsersByParentIdStudentsGetRequest($parentId, string $contentType = self::contentTypes['v1UsersByParentIdStudentsGet'][0])
    {

        // verify the required parameter 'parentId' is set
        if ($parentId === null || (is_array($parentId) && count($parentId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $parentId when calling v1UsersByParentIdStudentsGet'
            );
        }


        $resourcePath = '/v1/users/{parent_id}/students';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($parentId !== null) {
            $resourcePath = str_replace(
                '{' . 'parent_id' . '}',
                ObjectSerializer::toPathValue($parentId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v1UsersByUserIdAddressesByAddressIdByAddressTypeIdDelete
     *
     * Users address delete (BETA)
     *
     * @param  int $userId Format - int32. The ID of the user (required)
     * @param  int $addressId Format - int32. The ID of the user&#39;s address to delete. (required)
     * @param  int $addressTypeId Format - int32. The ID of the user&#39;s address type to delete. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdAddressesByAddressIdByAddressTypeIdDelete'] to see the possible values for this operation
     *
     * @throws \SKY\School\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function v1UsersByUserIdAddressesByAddressIdByAddressTypeIdDelete($userId, $addressId, $addressTypeId, string $contentType = self::contentTypes['v1UsersByUserIdAddressesByAddressIdByAddressTypeIdDelete'][0])
    {
        $this->v1UsersByUserIdAddressesByAddressIdByAddressTypeIdDeleteWithHttpInfo($userId, $addressId, $addressTypeId, $contentType);
    }

    /**
     * Operation v1UsersByUserIdAddressesByAddressIdByAddressTypeIdDeleteWithHttpInfo
     *
     * Users address delete (BETA)
     *
     * @param  int $userId Format - int32. The ID of the user (required)
     * @param  int $addressId Format - int32. The ID of the user&#39;s address to delete. (required)
     * @param  int $addressTypeId Format - int32. The ID of the user&#39;s address type to delete. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdAddressesByAddressIdByAddressTypeIdDelete'] to see the possible values for this operation
     *
     * @throws \SKY\School\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function v1UsersByUserIdAddressesByAddressIdByAddressTypeIdDeleteWithHttpInfo($userId, $addressId, $addressTypeId, string $contentType = self::contentTypes['v1UsersByUserIdAddressesByAddressIdByAddressTypeIdDelete'][0])
    {
        $request = $this->v1UsersByUserIdAddressesByAddressIdByAddressTypeIdDeleteRequest($userId, $addressId, $addressTypeId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation v1UsersByUserIdAddressesByAddressIdByAddressTypeIdDeleteAsync
     *
     * Users address delete (BETA)
     *
     * @param  int $userId Format - int32. The ID of the user (required)
     * @param  int $addressId Format - int32. The ID of the user&#39;s address to delete. (required)
     * @param  int $addressTypeId Format - int32. The ID of the user&#39;s address type to delete. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdAddressesByAddressIdByAddressTypeIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1UsersByUserIdAddressesByAddressIdByAddressTypeIdDeleteAsync($userId, $addressId, $addressTypeId, string $contentType = self::contentTypes['v1UsersByUserIdAddressesByAddressIdByAddressTypeIdDelete'][0])
    {
        return $this->v1UsersByUserIdAddressesByAddressIdByAddressTypeIdDeleteAsyncWithHttpInfo($userId, $addressId, $addressTypeId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v1UsersByUserIdAddressesByAddressIdByAddressTypeIdDeleteAsyncWithHttpInfo
     *
     * Users address delete (BETA)
     *
     * @param  int $userId Format - int32. The ID of the user (required)
     * @param  int $addressId Format - int32. The ID of the user&#39;s address to delete. (required)
     * @param  int $addressTypeId Format - int32. The ID of the user&#39;s address type to delete. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdAddressesByAddressIdByAddressTypeIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1UsersByUserIdAddressesByAddressIdByAddressTypeIdDeleteAsyncWithHttpInfo($userId, $addressId, $addressTypeId, string $contentType = self::contentTypes['v1UsersByUserIdAddressesByAddressIdByAddressTypeIdDelete'][0])
    {
        $returnType = '';
        $request = $this->v1UsersByUserIdAddressesByAddressIdByAddressTypeIdDeleteRequest($userId, $addressId, $addressTypeId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v1UsersByUserIdAddressesByAddressIdByAddressTypeIdDelete'
     *
     * @param  int $userId Format - int32. The ID of the user (required)
     * @param  int $addressId Format - int32. The ID of the user&#39;s address to delete. (required)
     * @param  int $addressTypeId Format - int32. The ID of the user&#39;s address type to delete. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdAddressesByAddressIdByAddressTypeIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v1UsersByUserIdAddressesByAddressIdByAddressTypeIdDeleteRequest($userId, $addressId, $addressTypeId, string $contentType = self::contentTypes['v1UsersByUserIdAddressesByAddressIdByAddressTypeIdDelete'][0])
    {

        // verify the required parameter 'userId' is set
        if ($userId === null || (is_array($userId) && count($userId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userId when calling v1UsersByUserIdAddressesByAddressIdByAddressTypeIdDelete'
            );
        }

        // verify the required parameter 'addressId' is set
        if ($addressId === null || (is_array($addressId) && count($addressId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $addressId when calling v1UsersByUserIdAddressesByAddressIdByAddressTypeIdDelete'
            );
        }

        // verify the required parameter 'addressTypeId' is set
        if ($addressTypeId === null || (is_array($addressTypeId) && count($addressTypeId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $addressTypeId when calling v1UsersByUserIdAddressesByAddressIdByAddressTypeIdDelete'
            );
        }


        $resourcePath = '/v1/users/{user_id}/addresses/{address_id}/{address_type_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($userId !== null) {
            $resourcePath = str_replace(
                '{' . 'user_id' . '}',
                ObjectSerializer::toPathValue($userId),
                $resourcePath
            );
        }
        // path params
        if ($addressId !== null) {
            $resourcePath = str_replace(
                '{' . 'address_id' . '}',
                ObjectSerializer::toPathValue($addressId),
                $resourcePath
            );
        }
        // path params
        if ($addressTypeId !== null) {
            $resourcePath = str_replace(
                '{' . 'address_type_id' . '}',
                ObjectSerializer::toPathValue($addressTypeId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v1UsersByUserIdAddressesByAddressIdPatch
     *
     * Users address update
     *
     * @param  int $userId Format - int32. The ID of the user. (required)
     * @param  int $addressId Format - int32. The ID of the address to be updated. (required)
     * @param  \SKY\School\Model\AddressEdit $addressEdit Address information to be updated. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdAddressesByAddressIdPatch'] to see the possible values for this operation
     *
     * @throws \SKY\School\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return int
     */
    public function v1UsersByUserIdAddressesByAddressIdPatch($userId, $addressId, $addressEdit = null, string $contentType = self::contentTypes['v1UsersByUserIdAddressesByAddressIdPatch'][0])
    {
        [$response] = $this->v1UsersByUserIdAddressesByAddressIdPatchWithHttpInfo($userId, $addressId, $addressEdit, $contentType);
        return $response;
    }

    /**
     * Operation v1UsersByUserIdAddressesByAddressIdPatchWithHttpInfo
     *
     * Users address update
     *
     * @param  int $userId Format - int32. The ID of the user. (required)
     * @param  int $addressId Format - int32. The ID of the address to be updated. (required)
     * @param  \SKY\School\Model\AddressEdit $addressEdit Address information to be updated. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdAddressesByAddressIdPatch'] to see the possible values for this operation
     *
     * @throws \SKY\School\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function v1UsersByUserIdAddressesByAddressIdPatchWithHttpInfo($userId, $addressId, $addressEdit = null, string $contentType = self::contentTypes['v1UsersByUserIdAddressesByAddressIdPatch'][0])
    {
        $request = $this->v1UsersByUserIdAddressesByAddressIdPatchRequest($userId, $addressId, $addressEdit, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('int' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('int' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = 'int';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v1UsersByUserIdAddressesByAddressIdPatchAsync
     *
     * Users address update
     *
     * @param  int $userId Format - int32. The ID of the user. (required)
     * @param  int $addressId Format - int32. The ID of the address to be updated. (required)
     * @param  \SKY\School\Model\AddressEdit $addressEdit Address information to be updated. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdAddressesByAddressIdPatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1UsersByUserIdAddressesByAddressIdPatchAsync($userId, $addressId, $addressEdit = null, string $contentType = self::contentTypes['v1UsersByUserIdAddressesByAddressIdPatch'][0])
    {
        return $this->v1UsersByUserIdAddressesByAddressIdPatchAsyncWithHttpInfo($userId, $addressId, $addressEdit, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v1UsersByUserIdAddressesByAddressIdPatchAsyncWithHttpInfo
     *
     * Users address update
     *
     * @param  int $userId Format - int32. The ID of the user. (required)
     * @param  int $addressId Format - int32. The ID of the address to be updated. (required)
     * @param  \SKY\School\Model\AddressEdit $addressEdit Address information to be updated. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdAddressesByAddressIdPatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1UsersByUserIdAddressesByAddressIdPatchAsyncWithHttpInfo($userId, $addressId, $addressEdit = null, string $contentType = self::contentTypes['v1UsersByUserIdAddressesByAddressIdPatch'][0])
    {
        $returnType = 'int';
        $request = $this->v1UsersByUserIdAddressesByAddressIdPatchRequest($userId, $addressId, $addressEdit, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v1UsersByUserIdAddressesByAddressIdPatch'
     *
     * @param  int $userId Format - int32. The ID of the user. (required)
     * @param  int $addressId Format - int32. The ID of the address to be updated. (required)
     * @param  \SKY\School\Model\AddressEdit $addressEdit Address information to be updated. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdAddressesByAddressIdPatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v1UsersByUserIdAddressesByAddressIdPatchRequest($userId, $addressId, $addressEdit = null, string $contentType = self::contentTypes['v1UsersByUserIdAddressesByAddressIdPatch'][0])
    {

        // verify the required parameter 'userId' is set
        if ($userId === null || (is_array($userId) && count($userId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userId when calling v1UsersByUserIdAddressesByAddressIdPatch'
            );
        }

        // verify the required parameter 'addressId' is set
        if ($addressId === null || (is_array($addressId) && count($addressId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $addressId when calling v1UsersByUserIdAddressesByAddressIdPatch'
            );
        }



        $resourcePath = '/v1/users/{user_id}/addresses/{address_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($userId !== null) {
            $resourcePath = str_replace(
                '{' . 'user_id' . '}',
                ObjectSerializer::toPathValue($userId),
                $resourcePath
            );
        }
        // path params
        if ($addressId !== null) {
            $resourcePath = str_replace(
                '{' . 'address_id' . '}',
                ObjectSerializer::toPathValue($addressId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($addressEdit)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($addressEdit));
            } else {
                $httpBody = $addressEdit;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v1UsersByUserIdAddressesGet
     *
     * Users addresses by user ID
     *
     * @param  int $userId Format - int32. The ID of the user. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdAddressesGet'] to see the possible values for this operation
     *
     * @throws \SKY\School\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \SKY\School\Model\AddressReadCollection
     */
    public function v1UsersByUserIdAddressesGet($userId, string $contentType = self::contentTypes['v1UsersByUserIdAddressesGet'][0])
    {
        [$response] = $this->v1UsersByUserIdAddressesGetWithHttpInfo($userId, $contentType);
        return $response;
    }

    /**
     * Operation v1UsersByUserIdAddressesGetWithHttpInfo
     *
     * Users addresses by user ID
     *
     * @param  int $userId Format - int32. The ID of the user. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdAddressesGet'] to see the possible values for this operation
     *
     * @throws \SKY\School\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \SKY\School\Model\AddressReadCollection, HTTP status code, HTTP response headers (array of strings)
     */
    public function v1UsersByUserIdAddressesGetWithHttpInfo($userId, string $contentType = self::contentTypes['v1UsersByUserIdAddressesGet'][0])
    {
        $request = $this->v1UsersByUserIdAddressesGetRequest($userId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SKY\School\Model\AddressReadCollection' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SKY\School\Model\AddressReadCollection' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SKY\School\Model\AddressReadCollection', []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = '\SKY\School\Model\AddressReadCollection';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SKY\School\Model\AddressReadCollection',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v1UsersByUserIdAddressesGetAsync
     *
     * Users addresses by user ID
     *
     * @param  int $userId Format - int32. The ID of the user. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdAddressesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1UsersByUserIdAddressesGetAsync($userId, string $contentType = self::contentTypes['v1UsersByUserIdAddressesGet'][0])
    {
        return $this->v1UsersByUserIdAddressesGetAsyncWithHttpInfo($userId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v1UsersByUserIdAddressesGetAsyncWithHttpInfo
     *
     * Users addresses by user ID
     *
     * @param  int $userId Format - int32. The ID of the user. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdAddressesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1UsersByUserIdAddressesGetAsyncWithHttpInfo($userId, string $contentType = self::contentTypes['v1UsersByUserIdAddressesGet'][0])
    {
        $returnType = '\SKY\School\Model\AddressReadCollection';
        $request = $this->v1UsersByUserIdAddressesGetRequest($userId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v1UsersByUserIdAddressesGet'
     *
     * @param  int $userId Format - int32. The ID of the user. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdAddressesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v1UsersByUserIdAddressesGetRequest($userId, string $contentType = self::contentTypes['v1UsersByUserIdAddressesGet'][0])
    {

        // verify the required parameter 'userId' is set
        if ($userId === null || (is_array($userId) && count($userId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userId when calling v1UsersByUserIdAddressesGet'
            );
        }


        $resourcePath = '/v1/users/{user_id}/addresses';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($userId !== null) {
            $resourcePath = str_replace(
                '{' . 'user_id' . '}',
                ObjectSerializer::toPathValue($userId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v1UsersByUserIdAddressesPost
     *
     * Users address create
     *
     * @param  int $userId Format - int32. The ID of the user. (required)
     * @param  \SKY\School\Model\AddressAdd $addressAdd Address information to be updated. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdAddressesPost'] to see the possible values for this operation
     *
     * @throws \SKY\School\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return int
     */
    public function v1UsersByUserIdAddressesPost($userId, $addressAdd = null, string $contentType = self::contentTypes['v1UsersByUserIdAddressesPost'][0])
    {
        [$response] = $this->v1UsersByUserIdAddressesPostWithHttpInfo($userId, $addressAdd, $contentType);
        return $response;
    }

    /**
     * Operation v1UsersByUserIdAddressesPostWithHttpInfo
     *
     * Users address create
     *
     * @param  int $userId Format - int32. The ID of the user. (required)
     * @param  \SKY\School\Model\AddressAdd $addressAdd Address information to be updated. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdAddressesPost'] to see the possible values for this operation
     *
     * @throws \SKY\School\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function v1UsersByUserIdAddressesPostWithHttpInfo($userId, $addressAdd = null, string $contentType = self::contentTypes['v1UsersByUserIdAddressesPost'][0])
    {
        $request = $this->v1UsersByUserIdAddressesPostRequest($userId, $addressAdd, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('int' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('int' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = 'int';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v1UsersByUserIdAddressesPostAsync
     *
     * Users address create
     *
     * @param  int $userId Format - int32. The ID of the user. (required)
     * @param  \SKY\School\Model\AddressAdd $addressAdd Address information to be updated. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdAddressesPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1UsersByUserIdAddressesPostAsync($userId, $addressAdd = null, string $contentType = self::contentTypes['v1UsersByUserIdAddressesPost'][0])
    {
        return $this->v1UsersByUserIdAddressesPostAsyncWithHttpInfo($userId, $addressAdd, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v1UsersByUserIdAddressesPostAsyncWithHttpInfo
     *
     * Users address create
     *
     * @param  int $userId Format - int32. The ID of the user. (required)
     * @param  \SKY\School\Model\AddressAdd $addressAdd Address information to be updated. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdAddressesPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1UsersByUserIdAddressesPostAsyncWithHttpInfo($userId, $addressAdd = null, string $contentType = self::contentTypes['v1UsersByUserIdAddressesPost'][0])
    {
        $returnType = 'int';
        $request = $this->v1UsersByUserIdAddressesPostRequest($userId, $addressAdd, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v1UsersByUserIdAddressesPost'
     *
     * @param  int $userId Format - int32. The ID of the user. (required)
     * @param  \SKY\School\Model\AddressAdd $addressAdd Address information to be updated. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdAddressesPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v1UsersByUserIdAddressesPostRequest($userId, $addressAdd = null, string $contentType = self::contentTypes['v1UsersByUserIdAddressesPost'][0])
    {

        // verify the required parameter 'userId' is set
        if ($userId === null || (is_array($userId) && count($userId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userId when calling v1UsersByUserIdAddressesPost'
            );
        }



        $resourcePath = '/v1/users/{user_id}/addresses';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($userId !== null) {
            $resourcePath = str_replace(
                '{' . 'user_id' . '}',
                ObjectSerializer::toPathValue($userId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($addressAdd)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($addressAdd));
            } else {
                $httpBody = $addressAdd;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v1UsersByUserIdAddressesSharePost
     *
     * Users address create - shared (BETA)
     *
     * @param  int $userId Format - int32. The Id of the user the existing address should be shared. (required)
     * @param  \SKY\School\Model\AddressShare $addressShare The details about the address that should be shared with the user. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdAddressesSharePost'] to see the possible values for this operation
     *
     * @throws \SKY\School\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return int
     */
    public function v1UsersByUserIdAddressesSharePost($userId, $addressShare = null, string $contentType = self::contentTypes['v1UsersByUserIdAddressesSharePost'][0])
    {
        [$response] = $this->v1UsersByUserIdAddressesSharePostWithHttpInfo($userId, $addressShare, $contentType);
        return $response;
    }

    /**
     * Operation v1UsersByUserIdAddressesSharePostWithHttpInfo
     *
     * Users address create - shared (BETA)
     *
     * @param  int $userId Format - int32. The Id of the user the existing address should be shared. (required)
     * @param  \SKY\School\Model\AddressShare $addressShare The details about the address that should be shared with the user. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdAddressesSharePost'] to see the possible values for this operation
     *
     * @throws \SKY\School\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function v1UsersByUserIdAddressesSharePostWithHttpInfo($userId, $addressShare = null, string $contentType = self::contentTypes['v1UsersByUserIdAddressesSharePost'][0])
    {
        $request = $this->v1UsersByUserIdAddressesSharePostRequest($userId, $addressShare, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('int' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('int' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = 'int';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v1UsersByUserIdAddressesSharePostAsync
     *
     * Users address create - shared (BETA)
     *
     * @param  int $userId Format - int32. The Id of the user the existing address should be shared. (required)
     * @param  \SKY\School\Model\AddressShare $addressShare The details about the address that should be shared with the user. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdAddressesSharePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1UsersByUserIdAddressesSharePostAsync($userId, $addressShare = null, string $contentType = self::contentTypes['v1UsersByUserIdAddressesSharePost'][0])
    {
        return $this->v1UsersByUserIdAddressesSharePostAsyncWithHttpInfo($userId, $addressShare, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v1UsersByUserIdAddressesSharePostAsyncWithHttpInfo
     *
     * Users address create - shared (BETA)
     *
     * @param  int $userId Format - int32. The Id of the user the existing address should be shared. (required)
     * @param  \SKY\School\Model\AddressShare $addressShare The details about the address that should be shared with the user. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdAddressesSharePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1UsersByUserIdAddressesSharePostAsyncWithHttpInfo($userId, $addressShare = null, string $contentType = self::contentTypes['v1UsersByUserIdAddressesSharePost'][0])
    {
        $returnType = 'int';
        $request = $this->v1UsersByUserIdAddressesSharePostRequest($userId, $addressShare, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v1UsersByUserIdAddressesSharePost'
     *
     * @param  int $userId Format - int32. The Id of the user the existing address should be shared. (required)
     * @param  \SKY\School\Model\AddressShare $addressShare The details about the address that should be shared with the user. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdAddressesSharePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v1UsersByUserIdAddressesSharePostRequest($userId, $addressShare = null, string $contentType = self::contentTypes['v1UsersByUserIdAddressesSharePost'][0])
    {

        // verify the required parameter 'userId' is set
        if ($userId === null || (is_array($userId) && count($userId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userId when calling v1UsersByUserIdAddressesSharePost'
            );
        }



        $resourcePath = '/v1/users/{user_id}/addresses/share';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($userId !== null) {
            $resourcePath = str_replace(
                '{' . 'user_id' . '}',
                ObjectSerializer::toPathValue($userId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($addressShare)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($addressShare));
            } else {
                $httpBody = $addressShare;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v1UsersByUserIdCustomfieldsGet
     *
     * Users custom fields single
     *
     * @param  int $userId Format - int32. The id of the user to get custom fields for. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdCustomfieldsGet'] to see the possible values for this operation
     *
     * @throws \SKY\School\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \SKY\School\Model\UserAdminCustomField
     */
    public function v1UsersByUserIdCustomfieldsGet($userId, string $contentType = self::contentTypes['v1UsersByUserIdCustomfieldsGet'][0])
    {
        [$response] = $this->v1UsersByUserIdCustomfieldsGetWithHttpInfo($userId, $contentType);
        return $response;
    }

    /**
     * Operation v1UsersByUserIdCustomfieldsGetWithHttpInfo
     *
     * Users custom fields single
     *
     * @param  int $userId Format - int32. The id of the user to get custom fields for. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdCustomfieldsGet'] to see the possible values for this operation
     *
     * @throws \SKY\School\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \SKY\School\Model\UserAdminCustomField, HTTP status code, HTTP response headers (array of strings)
     */
    public function v1UsersByUserIdCustomfieldsGetWithHttpInfo($userId, string $contentType = self::contentTypes['v1UsersByUserIdCustomfieldsGet'][0])
    {
        $request = $this->v1UsersByUserIdCustomfieldsGetRequest($userId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SKY\School\Model\UserAdminCustomField' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SKY\School\Model\UserAdminCustomField' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SKY\School\Model\UserAdminCustomField', []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = '\SKY\School\Model\UserAdminCustomField';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SKY\School\Model\UserAdminCustomField',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v1UsersByUserIdCustomfieldsGetAsync
     *
     * Users custom fields single
     *
     * @param  int $userId Format - int32. The id of the user to get custom fields for. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdCustomfieldsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1UsersByUserIdCustomfieldsGetAsync($userId, string $contentType = self::contentTypes['v1UsersByUserIdCustomfieldsGet'][0])
    {
        return $this->v1UsersByUserIdCustomfieldsGetAsyncWithHttpInfo($userId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v1UsersByUserIdCustomfieldsGetAsyncWithHttpInfo
     *
     * Users custom fields single
     *
     * @param  int $userId Format - int32. The id of the user to get custom fields for. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdCustomfieldsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1UsersByUserIdCustomfieldsGetAsyncWithHttpInfo($userId, string $contentType = self::contentTypes['v1UsersByUserIdCustomfieldsGet'][0])
    {
        $returnType = '\SKY\School\Model\UserAdminCustomField';
        $request = $this->v1UsersByUserIdCustomfieldsGetRequest($userId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v1UsersByUserIdCustomfieldsGet'
     *
     * @param  int $userId Format - int32. The id of the user to get custom fields for. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdCustomfieldsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v1UsersByUserIdCustomfieldsGetRequest($userId, string $contentType = self::contentTypes['v1UsersByUserIdCustomfieldsGet'][0])
    {

        // verify the required parameter 'userId' is set
        if ($userId === null || (is_array($userId) && count($userId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userId when calling v1UsersByUserIdCustomfieldsGet'
            );
        }


        $resourcePath = '/v1/users/{user_id}/customfields';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($userId !== null) {
            $resourcePath = str_replace(
                '{' . 'user_id' . '}',
                ObjectSerializer::toPathValue($userId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v1UsersByUserIdCustomfieldsListPatch
     *
     * Users custom fields list update
     *
     * @param  int $userId Format - int32. The Id of the user to update an existing custom field for. (required)
     * @param  \SKY\School\Model\UserAdminCustomFieldUpdate[] $userAdminCustomFieldUpdate Object that describes the custom field that should be updated. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdCustomfieldsListPatch'] to see the possible values for this operation
     *
     * @throws \SKY\School\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return bool
     */
    public function v1UsersByUserIdCustomfieldsListPatch($userId, $userAdminCustomFieldUpdate = null, string $contentType = self::contentTypes['v1UsersByUserIdCustomfieldsListPatch'][0])
    {
        [$response] = $this->v1UsersByUserIdCustomfieldsListPatchWithHttpInfo($userId, $userAdminCustomFieldUpdate, $contentType);
        return $response;
    }

    /**
     * Operation v1UsersByUserIdCustomfieldsListPatchWithHttpInfo
     *
     * Users custom fields list update
     *
     * @param  int $userId Format - int32. The Id of the user to update an existing custom field for. (required)
     * @param  \SKY\School\Model\UserAdminCustomFieldUpdate[] $userAdminCustomFieldUpdate Object that describes the custom field that should be updated. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdCustomfieldsListPatch'] to see the possible values for this operation
     *
     * @throws \SKY\School\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of bool, HTTP status code, HTTP response headers (array of strings)
     */
    public function v1UsersByUserIdCustomfieldsListPatchWithHttpInfo($userId, $userAdminCustomFieldUpdate = null, string $contentType = self::contentTypes['v1UsersByUserIdCustomfieldsListPatch'][0])
    {
        $request = $this->v1UsersByUserIdCustomfieldsListPatchRequest($userId, $userAdminCustomFieldUpdate, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('bool' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('bool' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'bool', []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = 'bool';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'bool',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v1UsersByUserIdCustomfieldsListPatchAsync
     *
     * Users custom fields list update
     *
     * @param  int $userId Format - int32. The Id of the user to update an existing custom field for. (required)
     * @param  \SKY\School\Model\UserAdminCustomFieldUpdate[] $userAdminCustomFieldUpdate Object that describes the custom field that should be updated. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdCustomfieldsListPatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1UsersByUserIdCustomfieldsListPatchAsync($userId, $userAdminCustomFieldUpdate = null, string $contentType = self::contentTypes['v1UsersByUserIdCustomfieldsListPatch'][0])
    {
        return $this->v1UsersByUserIdCustomfieldsListPatchAsyncWithHttpInfo($userId, $userAdminCustomFieldUpdate, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v1UsersByUserIdCustomfieldsListPatchAsyncWithHttpInfo
     *
     * Users custom fields list update
     *
     * @param  int $userId Format - int32. The Id of the user to update an existing custom field for. (required)
     * @param  \SKY\School\Model\UserAdminCustomFieldUpdate[] $userAdminCustomFieldUpdate Object that describes the custom field that should be updated. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdCustomfieldsListPatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1UsersByUserIdCustomfieldsListPatchAsyncWithHttpInfo($userId, $userAdminCustomFieldUpdate = null, string $contentType = self::contentTypes['v1UsersByUserIdCustomfieldsListPatch'][0])
    {
        $returnType = 'bool';
        $request = $this->v1UsersByUserIdCustomfieldsListPatchRequest($userId, $userAdminCustomFieldUpdate, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v1UsersByUserIdCustomfieldsListPatch'
     *
     * @param  int $userId Format - int32. The Id of the user to update an existing custom field for. (required)
     * @param  \SKY\School\Model\UserAdminCustomFieldUpdate[] $userAdminCustomFieldUpdate Object that describes the custom field that should be updated. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdCustomfieldsListPatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v1UsersByUserIdCustomfieldsListPatchRequest($userId, $userAdminCustomFieldUpdate = null, string $contentType = self::contentTypes['v1UsersByUserIdCustomfieldsListPatch'][0])
    {

        // verify the required parameter 'userId' is set
        if ($userId === null || (is_array($userId) && count($userId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userId when calling v1UsersByUserIdCustomfieldsListPatch'
            );
        }



        $resourcePath = '/v1/users/{user_id}/customfields/list';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($userId !== null) {
            $resourcePath = str_replace(
                '{' . 'user_id' . '}',
                ObjectSerializer::toPathValue($userId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($userAdminCustomFieldUpdate)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($userAdminCustomFieldUpdate));
            } else {
                $httpBody = $userAdminCustomFieldUpdate;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v1UsersByUserIdCustomfieldsListPost
     *
     * Users custom fields list create (BETA)
     *
     * @param  int $userId Format - int32. The Id of the user to create a custom field for (required)
     * @param  \SKY\School\Model\UserAdminCustomFieldCreate[] $userAdminCustomFieldCreate Object that describes the list of custom fields that will be created for the user. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdCustomfieldsListPost'] to see the possible values for this operation
     *
     * @throws \SKY\School\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return bool
     */
    public function v1UsersByUserIdCustomfieldsListPost($userId, $userAdminCustomFieldCreate = null, string $contentType = self::contentTypes['v1UsersByUserIdCustomfieldsListPost'][0])
    {
        [$response] = $this->v1UsersByUserIdCustomfieldsListPostWithHttpInfo($userId, $userAdminCustomFieldCreate, $contentType);
        return $response;
    }

    /**
     * Operation v1UsersByUserIdCustomfieldsListPostWithHttpInfo
     *
     * Users custom fields list create (BETA)
     *
     * @param  int $userId Format - int32. The Id of the user to create a custom field for (required)
     * @param  \SKY\School\Model\UserAdminCustomFieldCreate[] $userAdminCustomFieldCreate Object that describes the list of custom fields that will be created for the user. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdCustomfieldsListPost'] to see the possible values for this operation
     *
     * @throws \SKY\School\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of bool, HTTP status code, HTTP response headers (array of strings)
     */
    public function v1UsersByUserIdCustomfieldsListPostWithHttpInfo($userId, $userAdminCustomFieldCreate = null, string $contentType = self::contentTypes['v1UsersByUserIdCustomfieldsListPost'][0])
    {
        $request = $this->v1UsersByUserIdCustomfieldsListPostRequest($userId, $userAdminCustomFieldCreate, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('bool' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('bool' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'bool', []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = 'bool';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'bool',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v1UsersByUserIdCustomfieldsListPostAsync
     *
     * Users custom fields list create (BETA)
     *
     * @param  int $userId Format - int32. The Id of the user to create a custom field for (required)
     * @param  \SKY\School\Model\UserAdminCustomFieldCreate[] $userAdminCustomFieldCreate Object that describes the list of custom fields that will be created for the user. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdCustomfieldsListPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1UsersByUserIdCustomfieldsListPostAsync($userId, $userAdminCustomFieldCreate = null, string $contentType = self::contentTypes['v1UsersByUserIdCustomfieldsListPost'][0])
    {
        return $this->v1UsersByUserIdCustomfieldsListPostAsyncWithHttpInfo($userId, $userAdminCustomFieldCreate, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v1UsersByUserIdCustomfieldsListPostAsyncWithHttpInfo
     *
     * Users custom fields list create (BETA)
     *
     * @param  int $userId Format - int32. The Id of the user to create a custom field for (required)
     * @param  \SKY\School\Model\UserAdminCustomFieldCreate[] $userAdminCustomFieldCreate Object that describes the list of custom fields that will be created for the user. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdCustomfieldsListPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1UsersByUserIdCustomfieldsListPostAsyncWithHttpInfo($userId, $userAdminCustomFieldCreate = null, string $contentType = self::contentTypes['v1UsersByUserIdCustomfieldsListPost'][0])
    {
        $returnType = 'bool';
        $request = $this->v1UsersByUserIdCustomfieldsListPostRequest($userId, $userAdminCustomFieldCreate, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v1UsersByUserIdCustomfieldsListPost'
     *
     * @param  int $userId Format - int32. The Id of the user to create a custom field for (required)
     * @param  \SKY\School\Model\UserAdminCustomFieldCreate[] $userAdminCustomFieldCreate Object that describes the list of custom fields that will be created for the user. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdCustomfieldsListPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v1UsersByUserIdCustomfieldsListPostRequest($userId, $userAdminCustomFieldCreate = null, string $contentType = self::contentTypes['v1UsersByUserIdCustomfieldsListPost'][0])
    {

        // verify the required parameter 'userId' is set
        if ($userId === null || (is_array($userId) && count($userId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userId when calling v1UsersByUserIdCustomfieldsListPost'
            );
        }



        $resourcePath = '/v1/users/{user_id}/customfields/list';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($userId !== null) {
            $resourcePath = str_replace(
                '{' . 'user_id' . '}',
                ObjectSerializer::toPathValue($userId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($userAdminCustomFieldCreate)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($userAdminCustomFieldCreate));
            } else {
                $httpBody = $userAdminCustomFieldCreate;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v1UsersByUserIdCustomfieldsPatch
     *
     * Users custom fields update
     *
     * @param  int $userId Format - int32. The Id of the user to update an existing custom field for. (required)
     * @param  \SKY\School\Model\UserAdminCustomFieldUpdate $userAdminCustomFieldUpdate Object that describes the custom field that should be updated. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdCustomfieldsPatch'] to see the possible values for this operation
     *
     * @throws \SKY\School\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return bool
     */
    public function v1UsersByUserIdCustomfieldsPatch($userId, $userAdminCustomFieldUpdate = null, string $contentType = self::contentTypes['v1UsersByUserIdCustomfieldsPatch'][0])
    {
        [$response] = $this->v1UsersByUserIdCustomfieldsPatchWithHttpInfo($userId, $userAdminCustomFieldUpdate, $contentType);
        return $response;
    }

    /**
     * Operation v1UsersByUserIdCustomfieldsPatchWithHttpInfo
     *
     * Users custom fields update
     *
     * @param  int $userId Format - int32. The Id of the user to update an existing custom field for. (required)
     * @param  \SKY\School\Model\UserAdminCustomFieldUpdate $userAdminCustomFieldUpdate Object that describes the custom field that should be updated. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdCustomfieldsPatch'] to see the possible values for this operation
     *
     * @throws \SKY\School\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of bool, HTTP status code, HTTP response headers (array of strings)
     */
    public function v1UsersByUserIdCustomfieldsPatchWithHttpInfo($userId, $userAdminCustomFieldUpdate = null, string $contentType = self::contentTypes['v1UsersByUserIdCustomfieldsPatch'][0])
    {
        $request = $this->v1UsersByUserIdCustomfieldsPatchRequest($userId, $userAdminCustomFieldUpdate, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('bool' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('bool' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'bool', []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = 'bool';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'bool',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v1UsersByUserIdCustomfieldsPatchAsync
     *
     * Users custom fields update
     *
     * @param  int $userId Format - int32. The Id of the user to update an existing custom field for. (required)
     * @param  \SKY\School\Model\UserAdminCustomFieldUpdate $userAdminCustomFieldUpdate Object that describes the custom field that should be updated. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdCustomfieldsPatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1UsersByUserIdCustomfieldsPatchAsync($userId, $userAdminCustomFieldUpdate = null, string $contentType = self::contentTypes['v1UsersByUserIdCustomfieldsPatch'][0])
    {
        return $this->v1UsersByUserIdCustomfieldsPatchAsyncWithHttpInfo($userId, $userAdminCustomFieldUpdate, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v1UsersByUserIdCustomfieldsPatchAsyncWithHttpInfo
     *
     * Users custom fields update
     *
     * @param  int $userId Format - int32. The Id of the user to update an existing custom field for. (required)
     * @param  \SKY\School\Model\UserAdminCustomFieldUpdate $userAdminCustomFieldUpdate Object that describes the custom field that should be updated. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdCustomfieldsPatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1UsersByUserIdCustomfieldsPatchAsyncWithHttpInfo($userId, $userAdminCustomFieldUpdate = null, string $contentType = self::contentTypes['v1UsersByUserIdCustomfieldsPatch'][0])
    {
        $returnType = 'bool';
        $request = $this->v1UsersByUserIdCustomfieldsPatchRequest($userId, $userAdminCustomFieldUpdate, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v1UsersByUserIdCustomfieldsPatch'
     *
     * @param  int $userId Format - int32. The Id of the user to update an existing custom field for. (required)
     * @param  \SKY\School\Model\UserAdminCustomFieldUpdate $userAdminCustomFieldUpdate Object that describes the custom field that should be updated. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdCustomfieldsPatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v1UsersByUserIdCustomfieldsPatchRequest($userId, $userAdminCustomFieldUpdate = null, string $contentType = self::contentTypes['v1UsersByUserIdCustomfieldsPatch'][0])
    {

        // verify the required parameter 'userId' is set
        if ($userId === null || (is_array($userId) && count($userId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userId when calling v1UsersByUserIdCustomfieldsPatch'
            );
        }



        $resourcePath = '/v1/users/{user_id}/customfields';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($userId !== null) {
            $resourcePath = str_replace(
                '{' . 'user_id' . '}',
                ObjectSerializer::toPathValue($userId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($userAdminCustomFieldUpdate)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($userAdminCustomFieldUpdate));
            } else {
                $httpBody = $userAdminCustomFieldUpdate;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v1UsersByUserIdCustomfieldsPost
     *
     * Users custom fields create
     *
     * @param  int $userId Format - int32. The Id of the user to create a custom field for (required)
     * @param  \SKY\School\Model\UserAdminCustomFieldCreate $userAdminCustomFieldCreate Object that describes the custom field that will be created. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdCustomfieldsPost'] to see the possible values for this operation
     *
     * @throws \SKY\School\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return bool
     */
    public function v1UsersByUserIdCustomfieldsPost($userId, $userAdminCustomFieldCreate = null, string $contentType = self::contentTypes['v1UsersByUserIdCustomfieldsPost'][0])
    {
        [$response] = $this->v1UsersByUserIdCustomfieldsPostWithHttpInfo($userId, $userAdminCustomFieldCreate, $contentType);
        return $response;
    }

    /**
     * Operation v1UsersByUserIdCustomfieldsPostWithHttpInfo
     *
     * Users custom fields create
     *
     * @param  int $userId Format - int32. The Id of the user to create a custom field for (required)
     * @param  \SKY\School\Model\UserAdminCustomFieldCreate $userAdminCustomFieldCreate Object that describes the custom field that will be created. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdCustomfieldsPost'] to see the possible values for this operation
     *
     * @throws \SKY\School\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of bool, HTTP status code, HTTP response headers (array of strings)
     */
    public function v1UsersByUserIdCustomfieldsPostWithHttpInfo($userId, $userAdminCustomFieldCreate = null, string $contentType = self::contentTypes['v1UsersByUserIdCustomfieldsPost'][0])
    {
        $request = $this->v1UsersByUserIdCustomfieldsPostRequest($userId, $userAdminCustomFieldCreate, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('bool' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('bool' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'bool', []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = 'bool';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'bool',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v1UsersByUserIdCustomfieldsPostAsync
     *
     * Users custom fields create
     *
     * @param  int $userId Format - int32. The Id of the user to create a custom field for (required)
     * @param  \SKY\School\Model\UserAdminCustomFieldCreate $userAdminCustomFieldCreate Object that describes the custom field that will be created. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdCustomfieldsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1UsersByUserIdCustomfieldsPostAsync($userId, $userAdminCustomFieldCreate = null, string $contentType = self::contentTypes['v1UsersByUserIdCustomfieldsPost'][0])
    {
        return $this->v1UsersByUserIdCustomfieldsPostAsyncWithHttpInfo($userId, $userAdminCustomFieldCreate, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v1UsersByUserIdCustomfieldsPostAsyncWithHttpInfo
     *
     * Users custom fields create
     *
     * @param  int $userId Format - int32. The Id of the user to create a custom field for (required)
     * @param  \SKY\School\Model\UserAdminCustomFieldCreate $userAdminCustomFieldCreate Object that describes the custom field that will be created. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdCustomfieldsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1UsersByUserIdCustomfieldsPostAsyncWithHttpInfo($userId, $userAdminCustomFieldCreate = null, string $contentType = self::contentTypes['v1UsersByUserIdCustomfieldsPost'][0])
    {
        $returnType = 'bool';
        $request = $this->v1UsersByUserIdCustomfieldsPostRequest($userId, $userAdminCustomFieldCreate, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v1UsersByUserIdCustomfieldsPost'
     *
     * @param  int $userId Format - int32. The Id of the user to create a custom field for (required)
     * @param  \SKY\School\Model\UserAdminCustomFieldCreate $userAdminCustomFieldCreate Object that describes the custom field that will be created. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdCustomfieldsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v1UsersByUserIdCustomfieldsPostRequest($userId, $userAdminCustomFieldCreate = null, string $contentType = self::contentTypes['v1UsersByUserIdCustomfieldsPost'][0])
    {

        // verify the required parameter 'userId' is set
        if ($userId === null || (is_array($userId) && count($userId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userId when calling v1UsersByUserIdCustomfieldsPost'
            );
        }



        $resourcePath = '/v1/users/{user_id}/customfields';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($userId !== null) {
            $resourcePath = str_replace(
                '{' . 'user_id' . '}',
                ObjectSerializer::toPathValue($userId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($userAdminCustomFieldCreate)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($userAdminCustomFieldCreate));
            } else {
                $httpBody = $userAdminCustomFieldCreate;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v1UsersByUserIdEducationByEducationIdDelete
     *
     * User education delete (BETA)
     *
     * @param  int $userId Format - int32. (required)
     * @param  int $educationId Format - int32. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdEducationByEducationIdDelete'] to see the possible values for this operation
     *
     * @throws \SKY\School\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function v1UsersByUserIdEducationByEducationIdDelete($userId, $educationId, string $contentType = self::contentTypes['v1UsersByUserIdEducationByEducationIdDelete'][0])
    {
        $this->v1UsersByUserIdEducationByEducationIdDeleteWithHttpInfo($userId, $educationId, $contentType);
    }

    /**
     * Operation v1UsersByUserIdEducationByEducationIdDeleteWithHttpInfo
     *
     * User education delete (BETA)
     *
     * @param  int $userId Format - int32. (required)
     * @param  int $educationId Format - int32. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdEducationByEducationIdDelete'] to see the possible values for this operation
     *
     * @throws \SKY\School\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function v1UsersByUserIdEducationByEducationIdDeleteWithHttpInfo($userId, $educationId, string $contentType = self::contentTypes['v1UsersByUserIdEducationByEducationIdDelete'][0])
    {
        $request = $this->v1UsersByUserIdEducationByEducationIdDeleteRequest($userId, $educationId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation v1UsersByUserIdEducationByEducationIdDeleteAsync
     *
     * User education delete (BETA)
     *
     * @param  int $userId Format - int32. (required)
     * @param  int $educationId Format - int32. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdEducationByEducationIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1UsersByUserIdEducationByEducationIdDeleteAsync($userId, $educationId, string $contentType = self::contentTypes['v1UsersByUserIdEducationByEducationIdDelete'][0])
    {
        return $this->v1UsersByUserIdEducationByEducationIdDeleteAsyncWithHttpInfo($userId, $educationId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v1UsersByUserIdEducationByEducationIdDeleteAsyncWithHttpInfo
     *
     * User education delete (BETA)
     *
     * @param  int $userId Format - int32. (required)
     * @param  int $educationId Format - int32. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdEducationByEducationIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1UsersByUserIdEducationByEducationIdDeleteAsyncWithHttpInfo($userId, $educationId, string $contentType = self::contentTypes['v1UsersByUserIdEducationByEducationIdDelete'][0])
    {
        $returnType = '';
        $request = $this->v1UsersByUserIdEducationByEducationIdDeleteRequest($userId, $educationId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v1UsersByUserIdEducationByEducationIdDelete'
     *
     * @param  int $userId Format - int32. (required)
     * @param  int $educationId Format - int32. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdEducationByEducationIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v1UsersByUserIdEducationByEducationIdDeleteRequest($userId, $educationId, string $contentType = self::contentTypes['v1UsersByUserIdEducationByEducationIdDelete'][0])
    {

        // verify the required parameter 'userId' is set
        if ($userId === null || (is_array($userId) && count($userId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userId when calling v1UsersByUserIdEducationByEducationIdDelete'
            );
        }

        // verify the required parameter 'educationId' is set
        if ($educationId === null || (is_array($educationId) && count($educationId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $educationId when calling v1UsersByUserIdEducationByEducationIdDelete'
            );
        }


        $resourcePath = '/v1/users/{user_id}/education/{education_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($userId !== null) {
            $resourcePath = str_replace(
                '{' . 'user_id' . '}',
                ObjectSerializer::toPathValue($userId),
                $resourcePath
            );
        }
        // path params
        if ($educationId !== null) {
            $resourcePath = str_replace(
                '{' . 'education_id' . '}',
                ObjectSerializer::toPathValue($educationId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v1UsersByUserIdEducationByEducationIdPatch
     *
     * Users education update (BETA)
     *
     * @param  int $userId Format - int32. The ID of the user. (required)
     * @param  int $educationId Format - int32. The ID of the education. (required)
     * @param  \SKY\School\Model\EducationUpdate $educationUpdate The education model. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdEducationByEducationIdPatch'] to see the possible values for this operation
     *
     * @throws \SKY\School\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return int
     */
    public function v1UsersByUserIdEducationByEducationIdPatch($userId, $educationId, $educationUpdate = null, string $contentType = self::contentTypes['v1UsersByUserIdEducationByEducationIdPatch'][0])
    {
        [$response] = $this->v1UsersByUserIdEducationByEducationIdPatchWithHttpInfo($userId, $educationId, $educationUpdate, $contentType);
        return $response;
    }

    /**
     * Operation v1UsersByUserIdEducationByEducationIdPatchWithHttpInfo
     *
     * Users education update (BETA)
     *
     * @param  int $userId Format - int32. The ID of the user. (required)
     * @param  int $educationId Format - int32. The ID of the education. (required)
     * @param  \SKY\School\Model\EducationUpdate $educationUpdate The education model. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdEducationByEducationIdPatch'] to see the possible values for this operation
     *
     * @throws \SKY\School\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function v1UsersByUserIdEducationByEducationIdPatchWithHttpInfo($userId, $educationId, $educationUpdate = null, string $contentType = self::contentTypes['v1UsersByUserIdEducationByEducationIdPatch'][0])
    {
        $request = $this->v1UsersByUserIdEducationByEducationIdPatchRequest($userId, $educationId, $educationUpdate, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('int' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('int' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = 'int';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v1UsersByUserIdEducationByEducationIdPatchAsync
     *
     * Users education update (BETA)
     *
     * @param  int $userId Format - int32. The ID of the user. (required)
     * @param  int $educationId Format - int32. The ID of the education. (required)
     * @param  \SKY\School\Model\EducationUpdate $educationUpdate The education model. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdEducationByEducationIdPatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1UsersByUserIdEducationByEducationIdPatchAsync($userId, $educationId, $educationUpdate = null, string $contentType = self::contentTypes['v1UsersByUserIdEducationByEducationIdPatch'][0])
    {
        return $this->v1UsersByUserIdEducationByEducationIdPatchAsyncWithHttpInfo($userId, $educationId, $educationUpdate, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v1UsersByUserIdEducationByEducationIdPatchAsyncWithHttpInfo
     *
     * Users education update (BETA)
     *
     * @param  int $userId Format - int32. The ID of the user. (required)
     * @param  int $educationId Format - int32. The ID of the education. (required)
     * @param  \SKY\School\Model\EducationUpdate $educationUpdate The education model. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdEducationByEducationIdPatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1UsersByUserIdEducationByEducationIdPatchAsyncWithHttpInfo($userId, $educationId, $educationUpdate = null, string $contentType = self::contentTypes['v1UsersByUserIdEducationByEducationIdPatch'][0])
    {
        $returnType = 'int';
        $request = $this->v1UsersByUserIdEducationByEducationIdPatchRequest($userId, $educationId, $educationUpdate, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v1UsersByUserIdEducationByEducationIdPatch'
     *
     * @param  int $userId Format - int32. The ID of the user. (required)
     * @param  int $educationId Format - int32. The ID of the education. (required)
     * @param  \SKY\School\Model\EducationUpdate $educationUpdate The education model. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdEducationByEducationIdPatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v1UsersByUserIdEducationByEducationIdPatchRequest($userId, $educationId, $educationUpdate = null, string $contentType = self::contentTypes['v1UsersByUserIdEducationByEducationIdPatch'][0])
    {

        // verify the required parameter 'userId' is set
        if ($userId === null || (is_array($userId) && count($userId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userId when calling v1UsersByUserIdEducationByEducationIdPatch'
            );
        }

        // verify the required parameter 'educationId' is set
        if ($educationId === null || (is_array($educationId) && count($educationId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $educationId when calling v1UsersByUserIdEducationByEducationIdPatch'
            );
        }



        $resourcePath = '/v1/users/{user_id}/education/{education_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($userId !== null) {
            $resourcePath = str_replace(
                '{' . 'user_id' . '}',
                ObjectSerializer::toPathValue($userId),
                $resourcePath
            );
        }
        // path params
        if ($educationId !== null) {
            $resourcePath = str_replace(
                '{' . 'education_id' . '}',
                ObjectSerializer::toPathValue($educationId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($educationUpdate)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($educationUpdate));
            } else {
                $httpBody = $educationUpdate;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v1UsersByUserIdEducationGet
     *
     * Users education by user
     *
     * @param  int $userId Format - int32. The ID of the user. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdEducationGet'] to see the possible values for this operation
     *
     * @throws \SKY\School\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \SKY\School\Model\EducationReadCollection
     */
    public function v1UsersByUserIdEducationGet($userId, string $contentType = self::contentTypes['v1UsersByUserIdEducationGet'][0])
    {
        [$response] = $this->v1UsersByUserIdEducationGetWithHttpInfo($userId, $contentType);
        return $response;
    }

    /**
     * Operation v1UsersByUserIdEducationGetWithHttpInfo
     *
     * Users education by user
     *
     * @param  int $userId Format - int32. The ID of the user. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdEducationGet'] to see the possible values for this operation
     *
     * @throws \SKY\School\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \SKY\School\Model\EducationReadCollection, HTTP status code, HTTP response headers (array of strings)
     */
    public function v1UsersByUserIdEducationGetWithHttpInfo($userId, string $contentType = self::contentTypes['v1UsersByUserIdEducationGet'][0])
    {
        $request = $this->v1UsersByUserIdEducationGetRequest($userId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SKY\School\Model\EducationReadCollection' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SKY\School\Model\EducationReadCollection' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SKY\School\Model\EducationReadCollection', []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = '\SKY\School\Model\EducationReadCollection';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SKY\School\Model\EducationReadCollection',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v1UsersByUserIdEducationGetAsync
     *
     * Users education by user
     *
     * @param  int $userId Format - int32. The ID of the user. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdEducationGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1UsersByUserIdEducationGetAsync($userId, string $contentType = self::contentTypes['v1UsersByUserIdEducationGet'][0])
    {
        return $this->v1UsersByUserIdEducationGetAsyncWithHttpInfo($userId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v1UsersByUserIdEducationGetAsyncWithHttpInfo
     *
     * Users education by user
     *
     * @param  int $userId Format - int32. The ID of the user. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdEducationGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1UsersByUserIdEducationGetAsyncWithHttpInfo($userId, string $contentType = self::contentTypes['v1UsersByUserIdEducationGet'][0])
    {
        $returnType = '\SKY\School\Model\EducationReadCollection';
        $request = $this->v1UsersByUserIdEducationGetRequest($userId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v1UsersByUserIdEducationGet'
     *
     * @param  int $userId Format - int32. The ID of the user. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdEducationGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v1UsersByUserIdEducationGetRequest($userId, string $contentType = self::contentTypes['v1UsersByUserIdEducationGet'][0])
    {

        // verify the required parameter 'userId' is set
        if ($userId === null || (is_array($userId) && count($userId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userId when calling v1UsersByUserIdEducationGet'
            );
        }


        $resourcePath = '/v1/users/{user_id}/education';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($userId !== null) {
            $resourcePath = str_replace(
                '{' . 'user_id' . '}',
                ObjectSerializer::toPathValue($userId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v1UsersByUserIdEducationPost
     *
     * Users education create (BETA)
     *
     * @param  int $userId Format - int32. The ID of the user. (required)
     * @param  \SKY\School\Model\EducationAdd $educationAdd The education model. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdEducationPost'] to see the possible values for this operation
     *
     * @throws \SKY\School\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return int
     */
    public function v1UsersByUserIdEducationPost($userId, $educationAdd = null, string $contentType = self::contentTypes['v1UsersByUserIdEducationPost'][0])
    {
        [$response] = $this->v1UsersByUserIdEducationPostWithHttpInfo($userId, $educationAdd, $contentType);
        return $response;
    }

    /**
     * Operation v1UsersByUserIdEducationPostWithHttpInfo
     *
     * Users education create (BETA)
     *
     * @param  int $userId Format - int32. The ID of the user. (required)
     * @param  \SKY\School\Model\EducationAdd $educationAdd The education model. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdEducationPost'] to see the possible values for this operation
     *
     * @throws \SKY\School\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function v1UsersByUserIdEducationPostWithHttpInfo($userId, $educationAdd = null, string $contentType = self::contentTypes['v1UsersByUserIdEducationPost'][0])
    {
        $request = $this->v1UsersByUserIdEducationPostRequest($userId, $educationAdd, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('int' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('int' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = 'int';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v1UsersByUserIdEducationPostAsync
     *
     * Users education create (BETA)
     *
     * @param  int $userId Format - int32. The ID of the user. (required)
     * @param  \SKY\School\Model\EducationAdd $educationAdd The education model. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdEducationPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1UsersByUserIdEducationPostAsync($userId, $educationAdd = null, string $contentType = self::contentTypes['v1UsersByUserIdEducationPost'][0])
    {
        return $this->v1UsersByUserIdEducationPostAsyncWithHttpInfo($userId, $educationAdd, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v1UsersByUserIdEducationPostAsyncWithHttpInfo
     *
     * Users education create (BETA)
     *
     * @param  int $userId Format - int32. The ID of the user. (required)
     * @param  \SKY\School\Model\EducationAdd $educationAdd The education model. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdEducationPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1UsersByUserIdEducationPostAsyncWithHttpInfo($userId, $educationAdd = null, string $contentType = self::contentTypes['v1UsersByUserIdEducationPost'][0])
    {
        $returnType = 'int';
        $request = $this->v1UsersByUserIdEducationPostRequest($userId, $educationAdd, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v1UsersByUserIdEducationPost'
     *
     * @param  int $userId Format - int32. The ID of the user. (required)
     * @param  \SKY\School\Model\EducationAdd $educationAdd The education model. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdEducationPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v1UsersByUserIdEducationPostRequest($userId, $educationAdd = null, string $contentType = self::contentTypes['v1UsersByUserIdEducationPost'][0])
    {

        // verify the required parameter 'userId' is set
        if ($userId === null || (is_array($userId) && count($userId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userId when calling v1UsersByUserIdEducationPost'
            );
        }



        $resourcePath = '/v1/users/{user_id}/education';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($userId !== null) {
            $resourcePath = str_replace(
                '{' . 'user_id' . '}',
                ObjectSerializer::toPathValue($userId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($educationAdd)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($educationAdd));
            } else {
                $httpBody = $educationAdd;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v1UsersByUserIdEmergencycontactsGet
     *
     * Users emergency contacts by user ID
     *
     * @param  int $userId Format - int32. The ID of the user. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdEmergencycontactsGet'] to see the possible values for this operation
     *
     * @throws \SKY\School\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \SKY\School\Model\EmergencyContactList
     */
    public function v1UsersByUserIdEmergencycontactsGet($userId, string $contentType = self::contentTypes['v1UsersByUserIdEmergencycontactsGet'][0])
    {
        [$response] = $this->v1UsersByUserIdEmergencycontactsGetWithHttpInfo($userId, $contentType);
        return $response;
    }

    /**
     * Operation v1UsersByUserIdEmergencycontactsGetWithHttpInfo
     *
     * Users emergency contacts by user ID
     *
     * @param  int $userId Format - int32. The ID of the user. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdEmergencycontactsGet'] to see the possible values for this operation
     *
     * @throws \SKY\School\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \SKY\School\Model\EmergencyContactList, HTTP status code, HTTP response headers (array of strings)
     */
    public function v1UsersByUserIdEmergencycontactsGetWithHttpInfo($userId, string $contentType = self::contentTypes['v1UsersByUserIdEmergencycontactsGet'][0])
    {
        $request = $this->v1UsersByUserIdEmergencycontactsGetRequest($userId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SKY\School\Model\EmergencyContactList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SKY\School\Model\EmergencyContactList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SKY\School\Model\EmergencyContactList', []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = '\SKY\School\Model\EmergencyContactList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SKY\School\Model\EmergencyContactList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v1UsersByUserIdEmergencycontactsGetAsync
     *
     * Users emergency contacts by user ID
     *
     * @param  int $userId Format - int32. The ID of the user. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdEmergencycontactsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1UsersByUserIdEmergencycontactsGetAsync($userId, string $contentType = self::contentTypes['v1UsersByUserIdEmergencycontactsGet'][0])
    {
        return $this->v1UsersByUserIdEmergencycontactsGetAsyncWithHttpInfo($userId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v1UsersByUserIdEmergencycontactsGetAsyncWithHttpInfo
     *
     * Users emergency contacts by user ID
     *
     * @param  int $userId Format - int32. The ID of the user. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdEmergencycontactsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1UsersByUserIdEmergencycontactsGetAsyncWithHttpInfo($userId, string $contentType = self::contentTypes['v1UsersByUserIdEmergencycontactsGet'][0])
    {
        $returnType = '\SKY\School\Model\EmergencyContactList';
        $request = $this->v1UsersByUserIdEmergencycontactsGetRequest($userId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v1UsersByUserIdEmergencycontactsGet'
     *
     * @param  int $userId Format - int32. The ID of the user. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdEmergencycontactsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v1UsersByUserIdEmergencycontactsGetRequest($userId, string $contentType = self::contentTypes['v1UsersByUserIdEmergencycontactsGet'][0])
    {

        // verify the required parameter 'userId' is set
        if ($userId === null || (is_array($userId) && count($userId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userId when calling v1UsersByUserIdEmergencycontactsGet'
            );
        }


        $resourcePath = '/v1/users/{user_id}/emergencycontacts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($userId !== null) {
            $resourcePath = str_replace(
                '{' . 'user_id' . '}',
                ObjectSerializer::toPathValue($userId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v1UsersByUserIdEmergencycontactsNonuserPost
     *
     * Users emergency contact non-user create
     *
     * @param  int $userId Format - int32. The ID of the user. (required)
     * @param  \SKY\School\Model\EmergencyContactNonUserCreate $emergencyContactNonUserCreate  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdEmergencycontactsNonuserPost'] to see the possible values for this operation
     *
     * @throws \SKY\School\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function v1UsersByUserIdEmergencycontactsNonuserPost($userId, $emergencyContactNonUserCreate = null, string $contentType = self::contentTypes['v1UsersByUserIdEmergencycontactsNonuserPost'][0])
    {
        $this->v1UsersByUserIdEmergencycontactsNonuserPostWithHttpInfo($userId, $emergencyContactNonUserCreate, $contentType);
    }

    /**
     * Operation v1UsersByUserIdEmergencycontactsNonuserPostWithHttpInfo
     *
     * Users emergency contact non-user create
     *
     * @param  int $userId Format - int32. The ID of the user. (required)
     * @param  \SKY\School\Model\EmergencyContactNonUserCreate $emergencyContactNonUserCreate  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdEmergencycontactsNonuserPost'] to see the possible values for this operation
     *
     * @throws \SKY\School\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function v1UsersByUserIdEmergencycontactsNonuserPostWithHttpInfo($userId, $emergencyContactNonUserCreate = null, string $contentType = self::contentTypes['v1UsersByUserIdEmergencycontactsNonuserPost'][0])
    {
        $request = $this->v1UsersByUserIdEmergencycontactsNonuserPostRequest($userId, $emergencyContactNonUserCreate, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation v1UsersByUserIdEmergencycontactsNonuserPostAsync
     *
     * Users emergency contact non-user create
     *
     * @param  int $userId Format - int32. The ID of the user. (required)
     * @param  \SKY\School\Model\EmergencyContactNonUserCreate $emergencyContactNonUserCreate  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdEmergencycontactsNonuserPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1UsersByUserIdEmergencycontactsNonuserPostAsync($userId, $emergencyContactNonUserCreate = null, string $contentType = self::contentTypes['v1UsersByUserIdEmergencycontactsNonuserPost'][0])
    {
        return $this->v1UsersByUserIdEmergencycontactsNonuserPostAsyncWithHttpInfo($userId, $emergencyContactNonUserCreate, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v1UsersByUserIdEmergencycontactsNonuserPostAsyncWithHttpInfo
     *
     * Users emergency contact non-user create
     *
     * @param  int $userId Format - int32. The ID of the user. (required)
     * @param  \SKY\School\Model\EmergencyContactNonUserCreate $emergencyContactNonUserCreate  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdEmergencycontactsNonuserPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1UsersByUserIdEmergencycontactsNonuserPostAsyncWithHttpInfo($userId, $emergencyContactNonUserCreate = null, string $contentType = self::contentTypes['v1UsersByUserIdEmergencycontactsNonuserPost'][0])
    {
        $returnType = '';
        $request = $this->v1UsersByUserIdEmergencycontactsNonuserPostRequest($userId, $emergencyContactNonUserCreate, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v1UsersByUserIdEmergencycontactsNonuserPost'
     *
     * @param  int $userId Format - int32. The ID of the user. (required)
     * @param  \SKY\School\Model\EmergencyContactNonUserCreate $emergencyContactNonUserCreate  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdEmergencycontactsNonuserPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v1UsersByUserIdEmergencycontactsNonuserPostRequest($userId, $emergencyContactNonUserCreate = null, string $contentType = self::contentTypes['v1UsersByUserIdEmergencycontactsNonuserPost'][0])
    {

        // verify the required parameter 'userId' is set
        if ($userId === null || (is_array($userId) && count($userId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userId when calling v1UsersByUserIdEmergencycontactsNonuserPost'
            );
        }



        $resourcePath = '/v1/users/{user_id}/emergencycontacts/nonuser';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($userId !== null) {
            $resourcePath = str_replace(
                '{' . 'user_id' . '}',
                ObjectSerializer::toPathValue($userId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($emergencyContactNonUserCreate)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($emergencyContactNonUserCreate));
            } else {
                $httpBody = $emergencyContactNonUserCreate;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v1UsersByUserIdEmergencycontactsUserPost
     *
     * Users emergency contact user create
     *
     * @param  int $userId Format - int32. The ID of the user. (required)
     * @param  \SKY\School\Model\EmergencyContactUserCreate $emergencyContactUserCreate  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdEmergencycontactsUserPost'] to see the possible values for this operation
     *
     * @throws \SKY\School\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function v1UsersByUserIdEmergencycontactsUserPost($userId, $emergencyContactUserCreate = null, string $contentType = self::contentTypes['v1UsersByUserIdEmergencycontactsUserPost'][0])
    {
        $this->v1UsersByUserIdEmergencycontactsUserPostWithHttpInfo($userId, $emergencyContactUserCreate, $contentType);
    }

    /**
     * Operation v1UsersByUserIdEmergencycontactsUserPostWithHttpInfo
     *
     * Users emergency contact user create
     *
     * @param  int $userId Format - int32. The ID of the user. (required)
     * @param  \SKY\School\Model\EmergencyContactUserCreate $emergencyContactUserCreate  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdEmergencycontactsUserPost'] to see the possible values for this operation
     *
     * @throws \SKY\School\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function v1UsersByUserIdEmergencycontactsUserPostWithHttpInfo($userId, $emergencyContactUserCreate = null, string $contentType = self::contentTypes['v1UsersByUserIdEmergencycontactsUserPost'][0])
    {
        $request = $this->v1UsersByUserIdEmergencycontactsUserPostRequest($userId, $emergencyContactUserCreate, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation v1UsersByUserIdEmergencycontactsUserPostAsync
     *
     * Users emergency contact user create
     *
     * @param  int $userId Format - int32. The ID of the user. (required)
     * @param  \SKY\School\Model\EmergencyContactUserCreate $emergencyContactUserCreate  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdEmergencycontactsUserPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1UsersByUserIdEmergencycontactsUserPostAsync($userId, $emergencyContactUserCreate = null, string $contentType = self::contentTypes['v1UsersByUserIdEmergencycontactsUserPost'][0])
    {
        return $this->v1UsersByUserIdEmergencycontactsUserPostAsyncWithHttpInfo($userId, $emergencyContactUserCreate, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v1UsersByUserIdEmergencycontactsUserPostAsyncWithHttpInfo
     *
     * Users emergency contact user create
     *
     * @param  int $userId Format - int32. The ID of the user. (required)
     * @param  \SKY\School\Model\EmergencyContactUserCreate $emergencyContactUserCreate  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdEmergencycontactsUserPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1UsersByUserIdEmergencycontactsUserPostAsyncWithHttpInfo($userId, $emergencyContactUserCreate = null, string $contentType = self::contentTypes['v1UsersByUserIdEmergencycontactsUserPost'][0])
    {
        $returnType = '';
        $request = $this->v1UsersByUserIdEmergencycontactsUserPostRequest($userId, $emergencyContactUserCreate, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v1UsersByUserIdEmergencycontactsUserPost'
     *
     * @param  int $userId Format - int32. The ID of the user. (required)
     * @param  \SKY\School\Model\EmergencyContactUserCreate $emergencyContactUserCreate  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdEmergencycontactsUserPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v1UsersByUserIdEmergencycontactsUserPostRequest($userId, $emergencyContactUserCreate = null, string $contentType = self::contentTypes['v1UsersByUserIdEmergencycontactsUserPost'][0])
    {

        // verify the required parameter 'userId' is set
        if ($userId === null || (is_array($userId) && count($userId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userId when calling v1UsersByUserIdEmergencycontactsUserPost'
            );
        }



        $resourcePath = '/v1/users/{user_id}/emergencycontacts/user';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($userId !== null) {
            $resourcePath = str_replace(
                '{' . 'user_id' . '}',
                ObjectSerializer::toPathValue($userId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($emergencyContactUserCreate)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($emergencyContactUserCreate));
            } else {
                $httpBody = $emergencyContactUserCreate;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v1UsersByUserIdEmploymentGet
     *
     * Users employment by user ID
     *
     * @param  int $userId Format - int32. The ID of the user. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdEmploymentGet'] to see the possible values for this operation
     *
     * @throws \SKY\School\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \SKY\School\Model\FacultyEmploymentRead
     */
    public function v1UsersByUserIdEmploymentGet($userId, string $contentType = self::contentTypes['v1UsersByUserIdEmploymentGet'][0])
    {
        [$response] = $this->v1UsersByUserIdEmploymentGetWithHttpInfo($userId, $contentType);
        return $response;
    }

    /**
     * Operation v1UsersByUserIdEmploymentGetWithHttpInfo
     *
     * Users employment by user ID
     *
     * @param  int $userId Format - int32. The ID of the user. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdEmploymentGet'] to see the possible values for this operation
     *
     * @throws \SKY\School\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \SKY\School\Model\FacultyEmploymentRead, HTTP status code, HTTP response headers (array of strings)
     */
    public function v1UsersByUserIdEmploymentGetWithHttpInfo($userId, string $contentType = self::contentTypes['v1UsersByUserIdEmploymentGet'][0])
    {
        $request = $this->v1UsersByUserIdEmploymentGetRequest($userId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SKY\School\Model\FacultyEmploymentRead' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SKY\School\Model\FacultyEmploymentRead' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SKY\School\Model\FacultyEmploymentRead', []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = '\SKY\School\Model\FacultyEmploymentRead';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SKY\School\Model\FacultyEmploymentRead',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v1UsersByUserIdEmploymentGetAsync
     *
     * Users employment by user ID
     *
     * @param  int $userId Format - int32. The ID of the user. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdEmploymentGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1UsersByUserIdEmploymentGetAsync($userId, string $contentType = self::contentTypes['v1UsersByUserIdEmploymentGet'][0])
    {
        return $this->v1UsersByUserIdEmploymentGetAsyncWithHttpInfo($userId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v1UsersByUserIdEmploymentGetAsyncWithHttpInfo
     *
     * Users employment by user ID
     *
     * @param  int $userId Format - int32. The ID of the user. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdEmploymentGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1UsersByUserIdEmploymentGetAsyncWithHttpInfo($userId, string $contentType = self::contentTypes['v1UsersByUserIdEmploymentGet'][0])
    {
        $returnType = '\SKY\School\Model\FacultyEmploymentRead';
        $request = $this->v1UsersByUserIdEmploymentGetRequest($userId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v1UsersByUserIdEmploymentGet'
     *
     * @param  int $userId Format - int32. The ID of the user. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdEmploymentGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v1UsersByUserIdEmploymentGetRequest($userId, string $contentType = self::contentTypes['v1UsersByUserIdEmploymentGet'][0])
    {

        // verify the required parameter 'userId' is set
        if ($userId === null || (is_array($userId) && count($userId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userId when calling v1UsersByUserIdEmploymentGet'
            );
        }


        $resourcePath = '/v1/users/{user_id}/employment';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($userId !== null) {
            $resourcePath = str_replace(
                '{' . 'user_id' . '}',
                ObjectSerializer::toPathValue($userId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v1UsersByUserIdGet
     *
     * User by ID
     *
     * @param  int $userId Format - int32. ID of the user to be returned. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdGet'] to see the possible values for this operation
     *
     * @throws \SKY\School\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \SKY\School\Model\UserRead
     */
    public function v1UsersByUserIdGet($userId, string $contentType = self::contentTypes['v1UsersByUserIdGet'][0])
    {
        [$response] = $this->v1UsersByUserIdGetWithHttpInfo($userId, $contentType);
        return $response;
    }

    /**
     * Operation v1UsersByUserIdGetWithHttpInfo
     *
     * User by ID
     *
     * @param  int $userId Format - int32. ID of the user to be returned. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdGet'] to see the possible values for this operation
     *
     * @throws \SKY\School\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \SKY\School\Model\UserRead, HTTP status code, HTTP response headers (array of strings)
     */
    public function v1UsersByUserIdGetWithHttpInfo($userId, string $contentType = self::contentTypes['v1UsersByUserIdGet'][0])
    {
        $request = $this->v1UsersByUserIdGetRequest($userId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SKY\School\Model\UserRead' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SKY\School\Model\UserRead' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SKY\School\Model\UserRead', []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = '\SKY\School\Model\UserRead';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SKY\School\Model\UserRead',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v1UsersByUserIdGetAsync
     *
     * User by ID
     *
     * @param  int $userId Format - int32. ID of the user to be returned. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1UsersByUserIdGetAsync($userId, string $contentType = self::contentTypes['v1UsersByUserIdGet'][0])
    {
        return $this->v1UsersByUserIdGetAsyncWithHttpInfo($userId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v1UsersByUserIdGetAsyncWithHttpInfo
     *
     * User by ID
     *
     * @param  int $userId Format - int32. ID of the user to be returned. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1UsersByUserIdGetAsyncWithHttpInfo($userId, string $contentType = self::contentTypes['v1UsersByUserIdGet'][0])
    {
        $returnType = '\SKY\School\Model\UserRead';
        $request = $this->v1UsersByUserIdGetRequest($userId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v1UsersByUserIdGet'
     *
     * @param  int $userId Format - int32. ID of the user to be returned. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v1UsersByUserIdGetRequest($userId, string $contentType = self::contentTypes['v1UsersByUserIdGet'][0])
    {

        // verify the required parameter 'userId' is set
        if ($userId === null || (is_array($userId) && count($userId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userId when calling v1UsersByUserIdGet'
            );
        }


        $resourcePath = '/v1/users/{user_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($userId !== null) {
            $resourcePath = str_replace(
                '{' . 'user_id' . '}',
                ObjectSerializer::toPathValue($userId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v1UsersByUserIdOccupationsByOccupationIdDelete
     *
     * Users occupation delete (BETA)
     *
     * @param  int $userId Format - int32. The ID of the user. (required)
     * @param  int $occupationId Format - int32. The ID of the occupation. (required)
     * @param  bool $current Current Employment Status (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdOccupationsByOccupationIdDelete'] to see the possible values for this operation
     *
     * @throws \SKY\School\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return int
     */
    public function v1UsersByUserIdOccupationsByOccupationIdDelete($userId, $occupationId, $current = null, string $contentType = self::contentTypes['v1UsersByUserIdOccupationsByOccupationIdDelete'][0])
    {
        [$response] = $this->v1UsersByUserIdOccupationsByOccupationIdDeleteWithHttpInfo($userId, $occupationId, $current, $contentType);
        return $response;
    }

    /**
     * Operation v1UsersByUserIdOccupationsByOccupationIdDeleteWithHttpInfo
     *
     * Users occupation delete (BETA)
     *
     * @param  int $userId Format - int32. The ID of the user. (required)
     * @param  int $occupationId Format - int32. The ID of the occupation. (required)
     * @param  bool $current Current Employment Status (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdOccupationsByOccupationIdDelete'] to see the possible values for this operation
     *
     * @throws \SKY\School\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function v1UsersByUserIdOccupationsByOccupationIdDeleteWithHttpInfo($userId, $occupationId, $current = null, string $contentType = self::contentTypes['v1UsersByUserIdOccupationsByOccupationIdDelete'][0])
    {
        $request = $this->v1UsersByUserIdOccupationsByOccupationIdDeleteRequest($userId, $occupationId, $current, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('int' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('int' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = 'int';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v1UsersByUserIdOccupationsByOccupationIdDeleteAsync
     *
     * Users occupation delete (BETA)
     *
     * @param  int $userId Format - int32. The ID of the user. (required)
     * @param  int $occupationId Format - int32. The ID of the occupation. (required)
     * @param  bool $current Current Employment Status (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdOccupationsByOccupationIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1UsersByUserIdOccupationsByOccupationIdDeleteAsync($userId, $occupationId, $current = null, string $contentType = self::contentTypes['v1UsersByUserIdOccupationsByOccupationIdDelete'][0])
    {
        return $this->v1UsersByUserIdOccupationsByOccupationIdDeleteAsyncWithHttpInfo($userId, $occupationId, $current, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v1UsersByUserIdOccupationsByOccupationIdDeleteAsyncWithHttpInfo
     *
     * Users occupation delete (BETA)
     *
     * @param  int $userId Format - int32. The ID of the user. (required)
     * @param  int $occupationId Format - int32. The ID of the occupation. (required)
     * @param  bool $current Current Employment Status (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdOccupationsByOccupationIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1UsersByUserIdOccupationsByOccupationIdDeleteAsyncWithHttpInfo($userId, $occupationId, $current = null, string $contentType = self::contentTypes['v1UsersByUserIdOccupationsByOccupationIdDelete'][0])
    {
        $returnType = 'int';
        $request = $this->v1UsersByUserIdOccupationsByOccupationIdDeleteRequest($userId, $occupationId, $current, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v1UsersByUserIdOccupationsByOccupationIdDelete'
     *
     * @param  int $userId Format - int32. The ID of the user. (required)
     * @param  int $occupationId Format - int32. The ID of the occupation. (required)
     * @param  bool $current Current Employment Status (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdOccupationsByOccupationIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v1UsersByUserIdOccupationsByOccupationIdDeleteRequest($userId, $occupationId, $current = null, string $contentType = self::contentTypes['v1UsersByUserIdOccupationsByOccupationIdDelete'][0])
    {

        // verify the required parameter 'userId' is set
        if ($userId === null || (is_array($userId) && count($userId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userId when calling v1UsersByUserIdOccupationsByOccupationIdDelete'
            );
        }

        // verify the required parameter 'occupationId' is set
        if ($occupationId === null || (is_array($occupationId) && count($occupationId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $occupationId when calling v1UsersByUserIdOccupationsByOccupationIdDelete'
            );
        }



        $resourcePath = '/v1/users/{user_id}/occupations/{occupation_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $current,
            'current', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($userId !== null) {
            $resourcePath = str_replace(
                '{' . 'user_id' . '}',
                ObjectSerializer::toPathValue($userId),
                $resourcePath
            );
        }
        // path params
        if ($occupationId !== null) {
            $resourcePath = str_replace(
                '{' . 'occupation_id' . '}',
                ObjectSerializer::toPathValue($occupationId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v1UsersByUserIdOccupationsByOccupationIdPatch
     *
     * Users occupation update
     *
     * @param  int $userId Format - int32. The ID of the user. (required)
     * @param  int $occupationId Format - int32. The ID of the occupation. (required)
     * @param  \SKY\School\Model\OccupationUpdate $occupationUpdate The occupation information to be updated. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdOccupationsByOccupationIdPatch'] to see the possible values for this operation
     *
     * @throws \SKY\School\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return int
     */
    public function v1UsersByUserIdOccupationsByOccupationIdPatch($userId, $occupationId, $occupationUpdate = null, string $contentType = self::contentTypes['v1UsersByUserIdOccupationsByOccupationIdPatch'][0])
    {
        [$response] = $this->v1UsersByUserIdOccupationsByOccupationIdPatchWithHttpInfo($userId, $occupationId, $occupationUpdate, $contentType);
        return $response;
    }

    /**
     * Operation v1UsersByUserIdOccupationsByOccupationIdPatchWithHttpInfo
     *
     * Users occupation update
     *
     * @param  int $userId Format - int32. The ID of the user. (required)
     * @param  int $occupationId Format - int32. The ID of the occupation. (required)
     * @param  \SKY\School\Model\OccupationUpdate $occupationUpdate The occupation information to be updated. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdOccupationsByOccupationIdPatch'] to see the possible values for this operation
     *
     * @throws \SKY\School\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function v1UsersByUserIdOccupationsByOccupationIdPatchWithHttpInfo($userId, $occupationId, $occupationUpdate = null, string $contentType = self::contentTypes['v1UsersByUserIdOccupationsByOccupationIdPatch'][0])
    {
        $request = $this->v1UsersByUserIdOccupationsByOccupationIdPatchRequest($userId, $occupationId, $occupationUpdate, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('int' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('int' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = 'int';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v1UsersByUserIdOccupationsByOccupationIdPatchAsync
     *
     * Users occupation update
     *
     * @param  int $userId Format - int32. The ID of the user. (required)
     * @param  int $occupationId Format - int32. The ID of the occupation. (required)
     * @param  \SKY\School\Model\OccupationUpdate $occupationUpdate The occupation information to be updated. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdOccupationsByOccupationIdPatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1UsersByUserIdOccupationsByOccupationIdPatchAsync($userId, $occupationId, $occupationUpdate = null, string $contentType = self::contentTypes['v1UsersByUserIdOccupationsByOccupationIdPatch'][0])
    {
        return $this->v1UsersByUserIdOccupationsByOccupationIdPatchAsyncWithHttpInfo($userId, $occupationId, $occupationUpdate, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v1UsersByUserIdOccupationsByOccupationIdPatchAsyncWithHttpInfo
     *
     * Users occupation update
     *
     * @param  int $userId Format - int32. The ID of the user. (required)
     * @param  int $occupationId Format - int32. The ID of the occupation. (required)
     * @param  \SKY\School\Model\OccupationUpdate $occupationUpdate The occupation information to be updated. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdOccupationsByOccupationIdPatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1UsersByUserIdOccupationsByOccupationIdPatchAsyncWithHttpInfo($userId, $occupationId, $occupationUpdate = null, string $contentType = self::contentTypes['v1UsersByUserIdOccupationsByOccupationIdPatch'][0])
    {
        $returnType = 'int';
        $request = $this->v1UsersByUserIdOccupationsByOccupationIdPatchRequest($userId, $occupationId, $occupationUpdate, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v1UsersByUserIdOccupationsByOccupationIdPatch'
     *
     * @param  int $userId Format - int32. The ID of the user. (required)
     * @param  int $occupationId Format - int32. The ID of the occupation. (required)
     * @param  \SKY\School\Model\OccupationUpdate $occupationUpdate The occupation information to be updated. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdOccupationsByOccupationIdPatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v1UsersByUserIdOccupationsByOccupationIdPatchRequest($userId, $occupationId, $occupationUpdate = null, string $contentType = self::contentTypes['v1UsersByUserIdOccupationsByOccupationIdPatch'][0])
    {

        // verify the required parameter 'userId' is set
        if ($userId === null || (is_array($userId) && count($userId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userId when calling v1UsersByUserIdOccupationsByOccupationIdPatch'
            );
        }

        // verify the required parameter 'occupationId' is set
        if ($occupationId === null || (is_array($occupationId) && count($occupationId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $occupationId when calling v1UsersByUserIdOccupationsByOccupationIdPatch'
            );
        }



        $resourcePath = '/v1/users/{user_id}/occupations/{occupation_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($userId !== null) {
            $resourcePath = str_replace(
                '{' . 'user_id' . '}',
                ObjectSerializer::toPathValue($userId),
                $resourcePath
            );
        }
        // path params
        if ($occupationId !== null) {
            $resourcePath = str_replace(
                '{' . 'occupation_id' . '}',
                ObjectSerializer::toPathValue($occupationId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($occupationUpdate)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($occupationUpdate));
            } else {
                $httpBody = $occupationUpdate;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v1UsersByUserIdOccupationsGet
     *
     * Users occupations by user ID
     *
     * @param  int $userId Format - int32. The ID of the user. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdOccupationsGet'] to see the possible values for this operation
     *
     * @throws \SKY\School\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \SKY\School\Model\OccupationReadCollection
     */
    public function v1UsersByUserIdOccupationsGet($userId, string $contentType = self::contentTypes['v1UsersByUserIdOccupationsGet'][0])
    {
        [$response] = $this->v1UsersByUserIdOccupationsGetWithHttpInfo($userId, $contentType);
        return $response;
    }

    /**
     * Operation v1UsersByUserIdOccupationsGetWithHttpInfo
     *
     * Users occupations by user ID
     *
     * @param  int $userId Format - int32. The ID of the user. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdOccupationsGet'] to see the possible values for this operation
     *
     * @throws \SKY\School\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \SKY\School\Model\OccupationReadCollection, HTTP status code, HTTP response headers (array of strings)
     */
    public function v1UsersByUserIdOccupationsGetWithHttpInfo($userId, string $contentType = self::contentTypes['v1UsersByUserIdOccupationsGet'][0])
    {
        $request = $this->v1UsersByUserIdOccupationsGetRequest($userId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SKY\School\Model\OccupationReadCollection' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SKY\School\Model\OccupationReadCollection' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SKY\School\Model\OccupationReadCollection', []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = '\SKY\School\Model\OccupationReadCollection';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SKY\School\Model\OccupationReadCollection',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v1UsersByUserIdOccupationsGetAsync
     *
     * Users occupations by user ID
     *
     * @param  int $userId Format - int32. The ID of the user. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdOccupationsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1UsersByUserIdOccupationsGetAsync($userId, string $contentType = self::contentTypes['v1UsersByUserIdOccupationsGet'][0])
    {
        return $this->v1UsersByUserIdOccupationsGetAsyncWithHttpInfo($userId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v1UsersByUserIdOccupationsGetAsyncWithHttpInfo
     *
     * Users occupations by user ID
     *
     * @param  int $userId Format - int32. The ID of the user. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdOccupationsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1UsersByUserIdOccupationsGetAsyncWithHttpInfo($userId, string $contentType = self::contentTypes['v1UsersByUserIdOccupationsGet'][0])
    {
        $returnType = '\SKY\School\Model\OccupationReadCollection';
        $request = $this->v1UsersByUserIdOccupationsGetRequest($userId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v1UsersByUserIdOccupationsGet'
     *
     * @param  int $userId Format - int32. The ID of the user. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdOccupationsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v1UsersByUserIdOccupationsGetRequest($userId, string $contentType = self::contentTypes['v1UsersByUserIdOccupationsGet'][0])
    {

        // verify the required parameter 'userId' is set
        if ($userId === null || (is_array($userId) && count($userId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userId when calling v1UsersByUserIdOccupationsGet'
            );
        }


        $resourcePath = '/v1/users/{user_id}/occupations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($userId !== null) {
            $resourcePath = str_replace(
                '{' . 'user_id' . '}',
                ObjectSerializer::toPathValue($userId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v1UsersByUserIdOccupationsPost
     *
     * Users occupation create
     *
     * @param  int $userId Format - int32. The ID of the user. (required)
     * @param  \SKY\School\Model\OccupationCreate $occupationCreate The occupation information to be created. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdOccupationsPost'] to see the possible values for this operation
     *
     * @throws \SKY\School\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return int
     */
    public function v1UsersByUserIdOccupationsPost($userId, $occupationCreate = null, string $contentType = self::contentTypes['v1UsersByUserIdOccupationsPost'][0])
    {
        [$response] = $this->v1UsersByUserIdOccupationsPostWithHttpInfo($userId, $occupationCreate, $contentType);
        return $response;
    }

    /**
     * Operation v1UsersByUserIdOccupationsPostWithHttpInfo
     *
     * Users occupation create
     *
     * @param  int $userId Format - int32. The ID of the user. (required)
     * @param  \SKY\School\Model\OccupationCreate $occupationCreate The occupation information to be created. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdOccupationsPost'] to see the possible values for this operation
     *
     * @throws \SKY\School\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function v1UsersByUserIdOccupationsPostWithHttpInfo($userId, $occupationCreate = null, string $contentType = self::contentTypes['v1UsersByUserIdOccupationsPost'][0])
    {
        $request = $this->v1UsersByUserIdOccupationsPostRequest($userId, $occupationCreate, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('int' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('int' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = 'int';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v1UsersByUserIdOccupationsPostAsync
     *
     * Users occupation create
     *
     * @param  int $userId Format - int32. The ID of the user. (required)
     * @param  \SKY\School\Model\OccupationCreate $occupationCreate The occupation information to be created. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdOccupationsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1UsersByUserIdOccupationsPostAsync($userId, $occupationCreate = null, string $contentType = self::contentTypes['v1UsersByUserIdOccupationsPost'][0])
    {
        return $this->v1UsersByUserIdOccupationsPostAsyncWithHttpInfo($userId, $occupationCreate, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v1UsersByUserIdOccupationsPostAsyncWithHttpInfo
     *
     * Users occupation create
     *
     * @param  int $userId Format - int32. The ID of the user. (required)
     * @param  \SKY\School\Model\OccupationCreate $occupationCreate The occupation information to be created. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdOccupationsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1UsersByUserIdOccupationsPostAsyncWithHttpInfo($userId, $occupationCreate = null, string $contentType = self::contentTypes['v1UsersByUserIdOccupationsPost'][0])
    {
        $returnType = 'int';
        $request = $this->v1UsersByUserIdOccupationsPostRequest($userId, $occupationCreate, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v1UsersByUserIdOccupationsPost'
     *
     * @param  int $userId Format - int32. The ID of the user. (required)
     * @param  \SKY\School\Model\OccupationCreate $occupationCreate The occupation information to be created. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdOccupationsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v1UsersByUserIdOccupationsPostRequest($userId, $occupationCreate = null, string $contentType = self::contentTypes['v1UsersByUserIdOccupationsPost'][0])
    {

        // verify the required parameter 'userId' is set
        if ($userId === null || (is_array($userId) && count($userId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userId when calling v1UsersByUserIdOccupationsPost'
            );
        }



        $resourcePath = '/v1/users/{user_id}/occupations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($userId !== null) {
            $resourcePath = str_replace(
                '{' . 'user_id' . '}',
                ObjectSerializer::toPathValue($userId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($occupationCreate)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($occupationCreate));
            } else {
                $httpBody = $occupationCreate;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v1UsersByUserIdPhonesByPhoneIdByPhoneTypeIdDelete
     *
     * Users phone delete (BETA)
     *
     * @param  int $userId Format - int32. The ID of the user. (required)
     * @param  int $phoneId Format - int32. The ID of the user&#39;s phone to delete. (required)
     * @param  int $phoneTypeId Format - int32. The ID of the phone type. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdPhonesByPhoneIdByPhoneTypeIdDelete'] to see the possible values for this operation
     *
     * @throws \SKY\School\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function v1UsersByUserIdPhonesByPhoneIdByPhoneTypeIdDelete($userId, $phoneId, $phoneTypeId, string $contentType = self::contentTypes['v1UsersByUserIdPhonesByPhoneIdByPhoneTypeIdDelete'][0])
    {
        $this->v1UsersByUserIdPhonesByPhoneIdByPhoneTypeIdDeleteWithHttpInfo($userId, $phoneId, $phoneTypeId, $contentType);
    }

    /**
     * Operation v1UsersByUserIdPhonesByPhoneIdByPhoneTypeIdDeleteWithHttpInfo
     *
     * Users phone delete (BETA)
     *
     * @param  int $userId Format - int32. The ID of the user. (required)
     * @param  int $phoneId Format - int32. The ID of the user&#39;s phone to delete. (required)
     * @param  int $phoneTypeId Format - int32. The ID of the phone type. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdPhonesByPhoneIdByPhoneTypeIdDelete'] to see the possible values for this operation
     *
     * @throws \SKY\School\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function v1UsersByUserIdPhonesByPhoneIdByPhoneTypeIdDeleteWithHttpInfo($userId, $phoneId, $phoneTypeId, string $contentType = self::contentTypes['v1UsersByUserIdPhonesByPhoneIdByPhoneTypeIdDelete'][0])
    {
        $request = $this->v1UsersByUserIdPhonesByPhoneIdByPhoneTypeIdDeleteRequest($userId, $phoneId, $phoneTypeId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation v1UsersByUserIdPhonesByPhoneIdByPhoneTypeIdDeleteAsync
     *
     * Users phone delete (BETA)
     *
     * @param  int $userId Format - int32. The ID of the user. (required)
     * @param  int $phoneId Format - int32. The ID of the user&#39;s phone to delete. (required)
     * @param  int $phoneTypeId Format - int32. The ID of the phone type. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdPhonesByPhoneIdByPhoneTypeIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1UsersByUserIdPhonesByPhoneIdByPhoneTypeIdDeleteAsync($userId, $phoneId, $phoneTypeId, string $contentType = self::contentTypes['v1UsersByUserIdPhonesByPhoneIdByPhoneTypeIdDelete'][0])
    {
        return $this->v1UsersByUserIdPhonesByPhoneIdByPhoneTypeIdDeleteAsyncWithHttpInfo($userId, $phoneId, $phoneTypeId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v1UsersByUserIdPhonesByPhoneIdByPhoneTypeIdDeleteAsyncWithHttpInfo
     *
     * Users phone delete (BETA)
     *
     * @param  int $userId Format - int32. The ID of the user. (required)
     * @param  int $phoneId Format - int32. The ID of the user&#39;s phone to delete. (required)
     * @param  int $phoneTypeId Format - int32. The ID of the phone type. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdPhonesByPhoneIdByPhoneTypeIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1UsersByUserIdPhonesByPhoneIdByPhoneTypeIdDeleteAsyncWithHttpInfo($userId, $phoneId, $phoneTypeId, string $contentType = self::contentTypes['v1UsersByUserIdPhonesByPhoneIdByPhoneTypeIdDelete'][0])
    {
        $returnType = '';
        $request = $this->v1UsersByUserIdPhonesByPhoneIdByPhoneTypeIdDeleteRequest($userId, $phoneId, $phoneTypeId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v1UsersByUserIdPhonesByPhoneIdByPhoneTypeIdDelete'
     *
     * @param  int $userId Format - int32. The ID of the user. (required)
     * @param  int $phoneId Format - int32. The ID of the user&#39;s phone to delete. (required)
     * @param  int $phoneTypeId Format - int32. The ID of the phone type. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdPhonesByPhoneIdByPhoneTypeIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v1UsersByUserIdPhonesByPhoneIdByPhoneTypeIdDeleteRequest($userId, $phoneId, $phoneTypeId, string $contentType = self::contentTypes['v1UsersByUserIdPhonesByPhoneIdByPhoneTypeIdDelete'][0])
    {

        // verify the required parameter 'userId' is set
        if ($userId === null || (is_array($userId) && count($userId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userId when calling v1UsersByUserIdPhonesByPhoneIdByPhoneTypeIdDelete'
            );
        }

        // verify the required parameter 'phoneId' is set
        if ($phoneId === null || (is_array($phoneId) && count($phoneId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $phoneId when calling v1UsersByUserIdPhonesByPhoneIdByPhoneTypeIdDelete'
            );
        }

        // verify the required parameter 'phoneTypeId' is set
        if ($phoneTypeId === null || (is_array($phoneTypeId) && count($phoneTypeId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $phoneTypeId when calling v1UsersByUserIdPhonesByPhoneIdByPhoneTypeIdDelete'
            );
        }


        $resourcePath = '/v1/users/{user_id}/phones/{phone_id}/{phone_type_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($userId !== null) {
            $resourcePath = str_replace(
                '{' . 'user_id' . '}',
                ObjectSerializer::toPathValue($userId),
                $resourcePath
            );
        }
        // path params
        if ($phoneId !== null) {
            $resourcePath = str_replace(
                '{' . 'phone_id' . '}',
                ObjectSerializer::toPathValue($phoneId),
                $resourcePath
            );
        }
        // path params
        if ($phoneTypeId !== null) {
            $resourcePath = str_replace(
                '{' . 'phone_type_id' . '}',
                ObjectSerializer::toPathValue($phoneTypeId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v1UsersByUserIdPhonesByPhoneIdPatch
     *
     * Users phone update
     *
     * @param  int $userId Format - int32. The ID of the user. (required)
     * @param  int $phoneId Format - int32. The phone id to be updated. (required)
     * @param  bool $splitPhoneIfShared Set to true if phone number is shared (optional, default to false)
     * @param  \SKY\School\Model\PhoneUpdate $phoneUpdate The phone information to be updated. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdPhonesByPhoneIdPatch'] to see the possible values for this operation
     *
     * @throws \SKY\School\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return int
     */
    public function v1UsersByUserIdPhonesByPhoneIdPatch($userId, $phoneId, $splitPhoneIfShared = false, $phoneUpdate = null, string $contentType = self::contentTypes['v1UsersByUserIdPhonesByPhoneIdPatch'][0])
    {
        [$response] = $this->v1UsersByUserIdPhonesByPhoneIdPatchWithHttpInfo($userId, $phoneId, $splitPhoneIfShared, $phoneUpdate, $contentType);
        return $response;
    }

    /**
     * Operation v1UsersByUserIdPhonesByPhoneIdPatchWithHttpInfo
     *
     * Users phone update
     *
     * @param  int $userId Format - int32. The ID of the user. (required)
     * @param  int $phoneId Format - int32. The phone id to be updated. (required)
     * @param  bool $splitPhoneIfShared Set to true if phone number is shared (optional, default to false)
     * @param  \SKY\School\Model\PhoneUpdate $phoneUpdate The phone information to be updated. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdPhonesByPhoneIdPatch'] to see the possible values for this operation
     *
     * @throws \SKY\School\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function v1UsersByUserIdPhonesByPhoneIdPatchWithHttpInfo($userId, $phoneId, $splitPhoneIfShared = false, $phoneUpdate = null, string $contentType = self::contentTypes['v1UsersByUserIdPhonesByPhoneIdPatch'][0])
    {
        $request = $this->v1UsersByUserIdPhonesByPhoneIdPatchRequest($userId, $phoneId, $splitPhoneIfShared, $phoneUpdate, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('int' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('int' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = 'int';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v1UsersByUserIdPhonesByPhoneIdPatchAsync
     *
     * Users phone update
     *
     * @param  int $userId Format - int32. The ID of the user. (required)
     * @param  int $phoneId Format - int32. The phone id to be updated. (required)
     * @param  bool $splitPhoneIfShared Set to true if phone number is shared (optional, default to false)
     * @param  \SKY\School\Model\PhoneUpdate $phoneUpdate The phone information to be updated. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdPhonesByPhoneIdPatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1UsersByUserIdPhonesByPhoneIdPatchAsync($userId, $phoneId, $splitPhoneIfShared = false, $phoneUpdate = null, string $contentType = self::contentTypes['v1UsersByUserIdPhonesByPhoneIdPatch'][0])
    {
        return $this->v1UsersByUserIdPhonesByPhoneIdPatchAsyncWithHttpInfo($userId, $phoneId, $splitPhoneIfShared, $phoneUpdate, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v1UsersByUserIdPhonesByPhoneIdPatchAsyncWithHttpInfo
     *
     * Users phone update
     *
     * @param  int $userId Format - int32. The ID of the user. (required)
     * @param  int $phoneId Format - int32. The phone id to be updated. (required)
     * @param  bool $splitPhoneIfShared Set to true if phone number is shared (optional, default to false)
     * @param  \SKY\School\Model\PhoneUpdate $phoneUpdate The phone information to be updated. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdPhonesByPhoneIdPatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1UsersByUserIdPhonesByPhoneIdPatchAsyncWithHttpInfo($userId, $phoneId, $splitPhoneIfShared = false, $phoneUpdate = null, string $contentType = self::contentTypes['v1UsersByUserIdPhonesByPhoneIdPatch'][0])
    {
        $returnType = 'int';
        $request = $this->v1UsersByUserIdPhonesByPhoneIdPatchRequest($userId, $phoneId, $splitPhoneIfShared, $phoneUpdate, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v1UsersByUserIdPhonesByPhoneIdPatch'
     *
     * @param  int $userId Format - int32. The ID of the user. (required)
     * @param  int $phoneId Format - int32. The phone id to be updated. (required)
     * @param  bool $splitPhoneIfShared Set to true if phone number is shared (optional, default to false)
     * @param  \SKY\School\Model\PhoneUpdate $phoneUpdate The phone information to be updated. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdPhonesByPhoneIdPatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v1UsersByUserIdPhonesByPhoneIdPatchRequest($userId, $phoneId, $splitPhoneIfShared = false, $phoneUpdate = null, string $contentType = self::contentTypes['v1UsersByUserIdPhonesByPhoneIdPatch'][0])
    {

        // verify the required parameter 'userId' is set
        if ($userId === null || (is_array($userId) && count($userId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userId when calling v1UsersByUserIdPhonesByPhoneIdPatch'
            );
        }

        // verify the required parameter 'phoneId' is set
        if ($phoneId === null || (is_array($phoneId) && count($phoneId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $phoneId when calling v1UsersByUserIdPhonesByPhoneIdPatch'
            );
        }




        $resourcePath = '/v1/users/{user_id}/phones/{phone_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $splitPhoneIfShared,
            'split_phone_if_shared', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($userId !== null) {
            $resourcePath = str_replace(
                '{' . 'user_id' . '}',
                ObjectSerializer::toPathValue($userId),
                $resourcePath
            );
        }
        // path params
        if ($phoneId !== null) {
            $resourcePath = str_replace(
                '{' . 'phone_id' . '}',
                ObjectSerializer::toPathValue($phoneId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($phoneUpdate)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($phoneUpdate));
            } else {
                $httpBody = $phoneUpdate;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v1UsersByUserIdPhonesGet
     *
     * Users phones by user
     *
     * @param  int $userId Format - int32. The ID of the user. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdPhonesGet'] to see the possible values for this operation
     *
     * @throws \SKY\School\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \SKY\School\Model\PhoneReadCollection
     */
    public function v1UsersByUserIdPhonesGet($userId, string $contentType = self::contentTypes['v1UsersByUserIdPhonesGet'][0])
    {
        [$response] = $this->v1UsersByUserIdPhonesGetWithHttpInfo($userId, $contentType);
        return $response;
    }

    /**
     * Operation v1UsersByUserIdPhonesGetWithHttpInfo
     *
     * Users phones by user
     *
     * @param  int $userId Format - int32. The ID of the user. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdPhonesGet'] to see the possible values for this operation
     *
     * @throws \SKY\School\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \SKY\School\Model\PhoneReadCollection, HTTP status code, HTTP response headers (array of strings)
     */
    public function v1UsersByUserIdPhonesGetWithHttpInfo($userId, string $contentType = self::contentTypes['v1UsersByUserIdPhonesGet'][0])
    {
        $request = $this->v1UsersByUserIdPhonesGetRequest($userId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SKY\School\Model\PhoneReadCollection' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SKY\School\Model\PhoneReadCollection' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SKY\School\Model\PhoneReadCollection', []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = '\SKY\School\Model\PhoneReadCollection';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SKY\School\Model\PhoneReadCollection',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v1UsersByUserIdPhonesGetAsync
     *
     * Users phones by user
     *
     * @param  int $userId Format - int32. The ID of the user. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdPhonesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1UsersByUserIdPhonesGetAsync($userId, string $contentType = self::contentTypes['v1UsersByUserIdPhonesGet'][0])
    {
        return $this->v1UsersByUserIdPhonesGetAsyncWithHttpInfo($userId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v1UsersByUserIdPhonesGetAsyncWithHttpInfo
     *
     * Users phones by user
     *
     * @param  int $userId Format - int32. The ID of the user. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdPhonesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1UsersByUserIdPhonesGetAsyncWithHttpInfo($userId, string $contentType = self::contentTypes['v1UsersByUserIdPhonesGet'][0])
    {
        $returnType = '\SKY\School\Model\PhoneReadCollection';
        $request = $this->v1UsersByUserIdPhonesGetRequest($userId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v1UsersByUserIdPhonesGet'
     *
     * @param  int $userId Format - int32. The ID of the user. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdPhonesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v1UsersByUserIdPhonesGetRequest($userId, string $contentType = self::contentTypes['v1UsersByUserIdPhonesGet'][0])
    {

        // verify the required parameter 'userId' is set
        if ($userId === null || (is_array($userId) && count($userId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userId when calling v1UsersByUserIdPhonesGet'
            );
        }


        $resourcePath = '/v1/users/{user_id}/phones';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($userId !== null) {
            $resourcePath = str_replace(
                '{' . 'user_id' . '}',
                ObjectSerializer::toPathValue($userId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v1UsersByUserIdPhonesPost
     *
     * Users phone create
     *
     * @param  int $userId Format - int32. The ID of the user. (required)
     * @param  \SKY\School\Model\PhoneAdd $phoneAdd The phone information to be created. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdPhonesPost'] to see the possible values for this operation
     *
     * @throws \SKY\School\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return int
     */
    public function v1UsersByUserIdPhonesPost($userId, $phoneAdd = null, string $contentType = self::contentTypes['v1UsersByUserIdPhonesPost'][0])
    {
        [$response] = $this->v1UsersByUserIdPhonesPostWithHttpInfo($userId, $phoneAdd, $contentType);
        return $response;
    }

    /**
     * Operation v1UsersByUserIdPhonesPostWithHttpInfo
     *
     * Users phone create
     *
     * @param  int $userId Format - int32. The ID of the user. (required)
     * @param  \SKY\School\Model\PhoneAdd $phoneAdd The phone information to be created. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdPhonesPost'] to see the possible values for this operation
     *
     * @throws \SKY\School\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function v1UsersByUserIdPhonesPostWithHttpInfo($userId, $phoneAdd = null, string $contentType = self::contentTypes['v1UsersByUserIdPhonesPost'][0])
    {
        $request = $this->v1UsersByUserIdPhonesPostRequest($userId, $phoneAdd, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('int' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('int' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = 'int';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v1UsersByUserIdPhonesPostAsync
     *
     * Users phone create
     *
     * @param  int $userId Format - int32. The ID of the user. (required)
     * @param  \SKY\School\Model\PhoneAdd $phoneAdd The phone information to be created. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdPhonesPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1UsersByUserIdPhonesPostAsync($userId, $phoneAdd = null, string $contentType = self::contentTypes['v1UsersByUserIdPhonesPost'][0])
    {
        return $this->v1UsersByUserIdPhonesPostAsyncWithHttpInfo($userId, $phoneAdd, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v1UsersByUserIdPhonesPostAsyncWithHttpInfo
     *
     * Users phone create
     *
     * @param  int $userId Format - int32. The ID of the user. (required)
     * @param  \SKY\School\Model\PhoneAdd $phoneAdd The phone information to be created. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdPhonesPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1UsersByUserIdPhonesPostAsyncWithHttpInfo($userId, $phoneAdd = null, string $contentType = self::contentTypes['v1UsersByUserIdPhonesPost'][0])
    {
        $returnType = 'int';
        $request = $this->v1UsersByUserIdPhonesPostRequest($userId, $phoneAdd, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v1UsersByUserIdPhonesPost'
     *
     * @param  int $userId Format - int32. The ID of the user. (required)
     * @param  \SKY\School\Model\PhoneAdd $phoneAdd The phone information to be created. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdPhonesPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v1UsersByUserIdPhonesPostRequest($userId, $phoneAdd = null, string $contentType = self::contentTypes['v1UsersByUserIdPhonesPost'][0])
    {

        // verify the required parameter 'userId' is set
        if ($userId === null || (is_array($userId) && count($userId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userId when calling v1UsersByUserIdPhonesPost'
            );
        }



        $resourcePath = '/v1/users/{user_id}/phones';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($userId !== null) {
            $resourcePath = str_replace(
                '{' . 'user_id' . '}',
                ObjectSerializer::toPathValue($userId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($phoneAdd)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($phoneAdd));
            } else {
                $httpBody = $phoneAdd;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v1UsersByUserIdPhonesSharePost
     *
     * Users phone create - shared (BETA)
     *
     * @param  int $userId Format - int32. The Id of the user the existing address should be shared. (required)
     * @param  \SKY\School\Model\PhoneShare $phoneShare The details about the phone number that should be shared with the user. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdPhonesSharePost'] to see the possible values for this operation
     *
     * @throws \SKY\School\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return int
     */
    public function v1UsersByUserIdPhonesSharePost($userId, $phoneShare = null, string $contentType = self::contentTypes['v1UsersByUserIdPhonesSharePost'][0])
    {
        [$response] = $this->v1UsersByUserIdPhonesSharePostWithHttpInfo($userId, $phoneShare, $contentType);
        return $response;
    }

    /**
     * Operation v1UsersByUserIdPhonesSharePostWithHttpInfo
     *
     * Users phone create - shared (BETA)
     *
     * @param  int $userId Format - int32. The Id of the user the existing address should be shared. (required)
     * @param  \SKY\School\Model\PhoneShare $phoneShare The details about the phone number that should be shared with the user. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdPhonesSharePost'] to see the possible values for this operation
     *
     * @throws \SKY\School\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function v1UsersByUserIdPhonesSharePostWithHttpInfo($userId, $phoneShare = null, string $contentType = self::contentTypes['v1UsersByUserIdPhonesSharePost'][0])
    {
        $request = $this->v1UsersByUserIdPhonesSharePostRequest($userId, $phoneShare, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('int' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('int' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = 'int';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v1UsersByUserIdPhonesSharePostAsync
     *
     * Users phone create - shared (BETA)
     *
     * @param  int $userId Format - int32. The Id of the user the existing address should be shared. (required)
     * @param  \SKY\School\Model\PhoneShare $phoneShare The details about the phone number that should be shared with the user. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdPhonesSharePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1UsersByUserIdPhonesSharePostAsync($userId, $phoneShare = null, string $contentType = self::contentTypes['v1UsersByUserIdPhonesSharePost'][0])
    {
        return $this->v1UsersByUserIdPhonesSharePostAsyncWithHttpInfo($userId, $phoneShare, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v1UsersByUserIdPhonesSharePostAsyncWithHttpInfo
     *
     * Users phone create - shared (BETA)
     *
     * @param  int $userId Format - int32. The Id of the user the existing address should be shared. (required)
     * @param  \SKY\School\Model\PhoneShare $phoneShare The details about the phone number that should be shared with the user. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdPhonesSharePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1UsersByUserIdPhonesSharePostAsyncWithHttpInfo($userId, $phoneShare = null, string $contentType = self::contentTypes['v1UsersByUserIdPhonesSharePost'][0])
    {
        $returnType = 'int';
        $request = $this->v1UsersByUserIdPhonesSharePostRequest($userId, $phoneShare, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v1UsersByUserIdPhonesSharePost'
     *
     * @param  int $userId Format - int32. The Id of the user the existing address should be shared. (required)
     * @param  \SKY\School\Model\PhoneShare $phoneShare The details about the phone number that should be shared with the user. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdPhonesSharePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v1UsersByUserIdPhonesSharePostRequest($userId, $phoneShare = null, string $contentType = self::contentTypes['v1UsersByUserIdPhonesSharePost'][0])
    {

        // verify the required parameter 'userId' is set
        if ($userId === null || (is_array($userId) && count($userId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userId when calling v1UsersByUserIdPhonesSharePost'
            );
        }



        $resourcePath = '/v1/users/{user_id}/phones/share';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($userId !== null) {
            $resourcePath = str_replace(
                '{' . 'user_id' . '}',
                ObjectSerializer::toPathValue($userId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($phoneShare)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($phoneShare));
            } else {
                $httpBody = $phoneShare;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v1UsersByUserIdRelationshipsDelete
     *
     * Users relationship delete
     *
     * @param  int $userId Format - int32. The ID of the user for whom you are deleting the relationship. (required)
     * @param  int $leftUser Format - int32. ID of the other user in the relationship. (required)
     * @param  string $relationshipType Defines the relationship between left_user and this user. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdRelationshipsDelete'] to see the possible values for this operation
     *
     * @throws \SKY\School\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function v1UsersByUserIdRelationshipsDelete($userId, $leftUser, $relationshipType, string $contentType = self::contentTypes['v1UsersByUserIdRelationshipsDelete'][0])
    {
        $this->v1UsersByUserIdRelationshipsDeleteWithHttpInfo($userId, $leftUser, $relationshipType, $contentType);
    }

    /**
     * Operation v1UsersByUserIdRelationshipsDeleteWithHttpInfo
     *
     * Users relationship delete
     *
     * @param  int $userId Format - int32. The ID of the user for whom you are deleting the relationship. (required)
     * @param  int $leftUser Format - int32. ID of the other user in the relationship. (required)
     * @param  string $relationshipType Defines the relationship between left_user and this user. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdRelationshipsDelete'] to see the possible values for this operation
     *
     * @throws \SKY\School\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function v1UsersByUserIdRelationshipsDeleteWithHttpInfo($userId, $leftUser, $relationshipType, string $contentType = self::contentTypes['v1UsersByUserIdRelationshipsDelete'][0])
    {
        $request = $this->v1UsersByUserIdRelationshipsDeleteRequest($userId, $leftUser, $relationshipType, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation v1UsersByUserIdRelationshipsDeleteAsync
     *
     * Users relationship delete
     *
     * @param  int $userId Format - int32. The ID of the user for whom you are deleting the relationship. (required)
     * @param  int $leftUser Format - int32. ID of the other user in the relationship. (required)
     * @param  string $relationshipType Defines the relationship between left_user and this user. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdRelationshipsDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1UsersByUserIdRelationshipsDeleteAsync($userId, $leftUser, $relationshipType, string $contentType = self::contentTypes['v1UsersByUserIdRelationshipsDelete'][0])
    {
        return $this->v1UsersByUserIdRelationshipsDeleteAsyncWithHttpInfo($userId, $leftUser, $relationshipType, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v1UsersByUserIdRelationshipsDeleteAsyncWithHttpInfo
     *
     * Users relationship delete
     *
     * @param  int $userId Format - int32. The ID of the user for whom you are deleting the relationship. (required)
     * @param  int $leftUser Format - int32. ID of the other user in the relationship. (required)
     * @param  string $relationshipType Defines the relationship between left_user and this user. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdRelationshipsDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1UsersByUserIdRelationshipsDeleteAsyncWithHttpInfo($userId, $leftUser, $relationshipType, string $contentType = self::contentTypes['v1UsersByUserIdRelationshipsDelete'][0])
    {
        $returnType = '';
        $request = $this->v1UsersByUserIdRelationshipsDeleteRequest($userId, $leftUser, $relationshipType, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v1UsersByUserIdRelationshipsDelete'
     *
     * @param  int $userId Format - int32. The ID of the user for whom you are deleting the relationship. (required)
     * @param  int $leftUser Format - int32. ID of the other user in the relationship. (required)
     * @param  string $relationshipType Defines the relationship between left_user and this user. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdRelationshipsDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v1UsersByUserIdRelationshipsDeleteRequest($userId, $leftUser, $relationshipType, string $contentType = self::contentTypes['v1UsersByUserIdRelationshipsDelete'][0])
    {

        // verify the required parameter 'userId' is set
        if ($userId === null || (is_array($userId) && count($userId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userId when calling v1UsersByUserIdRelationshipsDelete'
            );
        }

        // verify the required parameter 'leftUser' is set
        if ($leftUser === null || (is_array($leftUser) && count($leftUser) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $leftUser when calling v1UsersByUserIdRelationshipsDelete'
            );
        }

        // verify the required parameter 'relationshipType' is set
        if ($relationshipType === null || (is_array($relationshipType) && count($relationshipType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $relationshipType when calling v1UsersByUserIdRelationshipsDelete'
            );
        }


        $resourcePath = '/v1/users/{user_id}/relationships';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $leftUser,
            'left_user', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $relationshipType,
            'relationship_type', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);


        // path params
        if ($userId !== null) {
            $resourcePath = str_replace(
                '{' . 'user_id' . '}',
                ObjectSerializer::toPathValue($userId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v1UsersByUserIdRelationshipsGet
     *
     * Users relationships by user
     *
     * @param  int $userId Format - int32. The ID of the user. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdRelationshipsGet'] to see the possible values for this operation
     *
     * @throws \SKY\School\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \SKY\School\Model\RelationshipReadCollection
     */
    public function v1UsersByUserIdRelationshipsGet($userId, string $contentType = self::contentTypes['v1UsersByUserIdRelationshipsGet'][0])
    {
        [$response] = $this->v1UsersByUserIdRelationshipsGetWithHttpInfo($userId, $contentType);
        return $response;
    }

    /**
     * Operation v1UsersByUserIdRelationshipsGetWithHttpInfo
     *
     * Users relationships by user
     *
     * @param  int $userId Format - int32. The ID of the user. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdRelationshipsGet'] to see the possible values for this operation
     *
     * @throws \SKY\School\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \SKY\School\Model\RelationshipReadCollection, HTTP status code, HTTP response headers (array of strings)
     */
    public function v1UsersByUserIdRelationshipsGetWithHttpInfo($userId, string $contentType = self::contentTypes['v1UsersByUserIdRelationshipsGet'][0])
    {
        $request = $this->v1UsersByUserIdRelationshipsGetRequest($userId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SKY\School\Model\RelationshipReadCollection' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SKY\School\Model\RelationshipReadCollection' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SKY\School\Model\RelationshipReadCollection', []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = '\SKY\School\Model\RelationshipReadCollection';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SKY\School\Model\RelationshipReadCollection',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v1UsersByUserIdRelationshipsGetAsync
     *
     * Users relationships by user
     *
     * @param  int $userId Format - int32. The ID of the user. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdRelationshipsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1UsersByUserIdRelationshipsGetAsync($userId, string $contentType = self::contentTypes['v1UsersByUserIdRelationshipsGet'][0])
    {
        return $this->v1UsersByUserIdRelationshipsGetAsyncWithHttpInfo($userId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v1UsersByUserIdRelationshipsGetAsyncWithHttpInfo
     *
     * Users relationships by user
     *
     * @param  int $userId Format - int32. The ID of the user. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdRelationshipsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1UsersByUserIdRelationshipsGetAsyncWithHttpInfo($userId, string $contentType = self::contentTypes['v1UsersByUserIdRelationshipsGet'][0])
    {
        $returnType = '\SKY\School\Model\RelationshipReadCollection';
        $request = $this->v1UsersByUserIdRelationshipsGetRequest($userId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v1UsersByUserIdRelationshipsGet'
     *
     * @param  int $userId Format - int32. The ID of the user. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdRelationshipsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v1UsersByUserIdRelationshipsGetRequest($userId, string $contentType = self::contentTypes['v1UsersByUserIdRelationshipsGet'][0])
    {

        // verify the required parameter 'userId' is set
        if ($userId === null || (is_array($userId) && count($userId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userId when calling v1UsersByUserIdRelationshipsGet'
            );
        }


        $resourcePath = '/v1/users/{user_id}/relationships';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($userId !== null) {
            $resourcePath = str_replace(
                '{' . 'user_id' . '}',
                ObjectSerializer::toPathValue($userId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v1UsersByUserIdRelationshipsPost
     *
     * Users relationship create
     *
     * @param  int $userId Format - int32. The ID of the user. (required)
     * @param  \SKY\School\Model\RelationshipCreate $relationshipCreate Defines the relationship to be created. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdRelationshipsPost'] to see the possible values for this operation
     *
     * @throws \SKY\School\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function v1UsersByUserIdRelationshipsPost($userId, $relationshipCreate = null, string $contentType = self::contentTypes['v1UsersByUserIdRelationshipsPost'][0])
    {
        $this->v1UsersByUserIdRelationshipsPostWithHttpInfo($userId, $relationshipCreate, $contentType);
    }

    /**
     * Operation v1UsersByUserIdRelationshipsPostWithHttpInfo
     *
     * Users relationship create
     *
     * @param  int $userId Format - int32. The ID of the user. (required)
     * @param  \SKY\School\Model\RelationshipCreate $relationshipCreate Defines the relationship to be created. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdRelationshipsPost'] to see the possible values for this operation
     *
     * @throws \SKY\School\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function v1UsersByUserIdRelationshipsPostWithHttpInfo($userId, $relationshipCreate = null, string $contentType = self::contentTypes['v1UsersByUserIdRelationshipsPost'][0])
    {
        $request = $this->v1UsersByUserIdRelationshipsPostRequest($userId, $relationshipCreate, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation v1UsersByUserIdRelationshipsPostAsync
     *
     * Users relationship create
     *
     * @param  int $userId Format - int32. The ID of the user. (required)
     * @param  \SKY\School\Model\RelationshipCreate $relationshipCreate Defines the relationship to be created. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdRelationshipsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1UsersByUserIdRelationshipsPostAsync($userId, $relationshipCreate = null, string $contentType = self::contentTypes['v1UsersByUserIdRelationshipsPost'][0])
    {
        return $this->v1UsersByUserIdRelationshipsPostAsyncWithHttpInfo($userId, $relationshipCreate, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v1UsersByUserIdRelationshipsPostAsyncWithHttpInfo
     *
     * Users relationship create
     *
     * @param  int $userId Format - int32. The ID of the user. (required)
     * @param  \SKY\School\Model\RelationshipCreate $relationshipCreate Defines the relationship to be created. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdRelationshipsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1UsersByUserIdRelationshipsPostAsyncWithHttpInfo($userId, $relationshipCreate = null, string $contentType = self::contentTypes['v1UsersByUserIdRelationshipsPost'][0])
    {
        $returnType = '';
        $request = $this->v1UsersByUserIdRelationshipsPostRequest($userId, $relationshipCreate, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v1UsersByUserIdRelationshipsPost'
     *
     * @param  int $userId Format - int32. The ID of the user. (required)
     * @param  \SKY\School\Model\RelationshipCreate $relationshipCreate Defines the relationship to be created. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersByUserIdRelationshipsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v1UsersByUserIdRelationshipsPostRequest($userId, $relationshipCreate = null, string $contentType = self::contentTypes['v1UsersByUserIdRelationshipsPost'][0])
    {

        // verify the required parameter 'userId' is set
        if ($userId === null || (is_array($userId) && count($userId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userId when calling v1UsersByUserIdRelationshipsPost'
            );
        }



        $resourcePath = '/v1/users/{user_id}/relationships';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($userId !== null) {
            $resourcePath = str_replace(
                '{' . 'user_id' . '}',
                ObjectSerializer::toPathValue($userId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($relationshipCreate)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($relationshipCreate));
            } else {
                $httpBody = $relationshipCreate;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v1UsersChangedGet
     *
     * Users changed by base role(s)
     *
     * @param  string $baseRoleIds Comma delimited list of base role IDs to get users for. (required)
     * @param  \DateTime $startDate Format - date-time (as date-time in RFC3339). The date to begin looking for changes. Use &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/ISO_8601\&quot; target&#x3D;\&quot;_blank\&quot;&gt;ISO-8601&lt;/a&gt; date format: 2003-04-21. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersChangedGet'] to see the possible values for this operation
     *
     * @throws \SKY\School\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \SKY\School\Model\UserExtendedCollection
     */
    public function v1UsersChangedGet($baseRoleIds, $startDate, string $contentType = self::contentTypes['v1UsersChangedGet'][0])
    {
        [$response] = $this->v1UsersChangedGetWithHttpInfo($baseRoleIds, $startDate, $contentType);
        return $response;
    }

    /**
     * Operation v1UsersChangedGetWithHttpInfo
     *
     * Users changed by base role(s)
     *
     * @param  string $baseRoleIds Comma delimited list of base role IDs to get users for. (required)
     * @param  \DateTime $startDate Format - date-time (as date-time in RFC3339). The date to begin looking for changes. Use &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/ISO_8601\&quot; target&#x3D;\&quot;_blank\&quot;&gt;ISO-8601&lt;/a&gt; date format: 2003-04-21. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersChangedGet'] to see the possible values for this operation
     *
     * @throws \SKY\School\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \SKY\School\Model\UserExtendedCollection, HTTP status code, HTTP response headers (array of strings)
     */
    public function v1UsersChangedGetWithHttpInfo($baseRoleIds, $startDate, string $contentType = self::contentTypes['v1UsersChangedGet'][0])
    {
        $request = $this->v1UsersChangedGetRequest($baseRoleIds, $startDate, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SKY\School\Model\UserExtendedCollection' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SKY\School\Model\UserExtendedCollection' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SKY\School\Model\UserExtendedCollection', []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = '\SKY\School\Model\UserExtendedCollection';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SKY\School\Model\UserExtendedCollection',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v1UsersChangedGetAsync
     *
     * Users changed by base role(s)
     *
     * @param  string $baseRoleIds Comma delimited list of base role IDs to get users for. (required)
     * @param  \DateTime $startDate Format - date-time (as date-time in RFC3339). The date to begin looking for changes. Use &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/ISO_8601\&quot; target&#x3D;\&quot;_blank\&quot;&gt;ISO-8601&lt;/a&gt; date format: 2003-04-21. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersChangedGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1UsersChangedGetAsync($baseRoleIds, $startDate, string $contentType = self::contentTypes['v1UsersChangedGet'][0])
    {
        return $this->v1UsersChangedGetAsyncWithHttpInfo($baseRoleIds, $startDate, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v1UsersChangedGetAsyncWithHttpInfo
     *
     * Users changed by base role(s)
     *
     * @param  string $baseRoleIds Comma delimited list of base role IDs to get users for. (required)
     * @param  \DateTime $startDate Format - date-time (as date-time in RFC3339). The date to begin looking for changes. Use &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/ISO_8601\&quot; target&#x3D;\&quot;_blank\&quot;&gt;ISO-8601&lt;/a&gt; date format: 2003-04-21. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersChangedGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1UsersChangedGetAsyncWithHttpInfo($baseRoleIds, $startDate, string $contentType = self::contentTypes['v1UsersChangedGet'][0])
    {
        $returnType = '\SKY\School\Model\UserExtendedCollection';
        $request = $this->v1UsersChangedGetRequest($baseRoleIds, $startDate, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v1UsersChangedGet'
     *
     * @param  string $baseRoleIds Comma delimited list of base role IDs to get users for. (required)
     * @param  \DateTime $startDate Format - date-time (as date-time in RFC3339). The date to begin looking for changes. Use &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/ISO_8601\&quot; target&#x3D;\&quot;_blank\&quot;&gt;ISO-8601&lt;/a&gt; date format: 2003-04-21. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersChangedGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v1UsersChangedGetRequest($baseRoleIds, $startDate, string $contentType = self::contentTypes['v1UsersChangedGet'][0])
    {

        // verify the required parameter 'baseRoleIds' is set
        if ($baseRoleIds === null || (is_array($baseRoleIds) && count($baseRoleIds) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $baseRoleIds when calling v1UsersChangedGet'
            );
        }

        // verify the required parameter 'startDate' is set
        if ($startDate === null || (is_array($startDate) && count($startDate) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $startDate when calling v1UsersChangedGet'
            );
        }


        $resourcePath = '/v1/users/changed';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $baseRoleIds,
            'base_role_ids', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $startDate,
            'start_date', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v1UsersCustomfieldsGet
     *
     * Users custom fields list by base role(s)
     *
     * @param  string $baseRoleIds A comma delimited list of base role IDs to get users for. Example: &#x60;&#x60;&#x60;base_role_ids&#x3D;14,16&#x60;&#x60;&#x60; for Students and Parents. (required)
     * @param  int $marker Format - int32. The user&#39;s &#x60;&#x60;&#x60;id&#x60;&#x60;&#x60; to start at to return the next batch of data. Results will start with the next user in the result set. (optional)
     * @param  string $fieldIds A comma delimited list of field IDs to filter the result set down to. Only matching custom fields will be returned from that result set for all users in that set even if they don&#39;t have any data for the given &#x60;&#x60;&#x60;field_ids&#x60;&#x60;&#x60;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersCustomfieldsGet'] to see the possible values for this operation
     *
     * @throws \SKY\School\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \SKY\School\Model\UserAdminCustomFieldCollection
     */
    public function v1UsersCustomfieldsGet($baseRoleIds, $marker = null, $fieldIds = null, string $contentType = self::contentTypes['v1UsersCustomfieldsGet'][0])
    {
        [$response] = $this->v1UsersCustomfieldsGetWithHttpInfo($baseRoleIds, $marker, $fieldIds, $contentType);
        return $response;
    }

    /**
     * Operation v1UsersCustomfieldsGetWithHttpInfo
     *
     * Users custom fields list by base role(s)
     *
     * @param  string $baseRoleIds A comma delimited list of base role IDs to get users for. Example: &#x60;&#x60;&#x60;base_role_ids&#x3D;14,16&#x60;&#x60;&#x60; for Students and Parents. (required)
     * @param  int $marker Format - int32. The user&#39;s &#x60;&#x60;&#x60;id&#x60;&#x60;&#x60; to start at to return the next batch of data. Results will start with the next user in the result set. (optional)
     * @param  string $fieldIds A comma delimited list of field IDs to filter the result set down to. Only matching custom fields will be returned from that result set for all users in that set even if they don&#39;t have any data for the given &#x60;&#x60;&#x60;field_ids&#x60;&#x60;&#x60;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersCustomfieldsGet'] to see the possible values for this operation
     *
     * @throws \SKY\School\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \SKY\School\Model\UserAdminCustomFieldCollection, HTTP status code, HTTP response headers (array of strings)
     */
    public function v1UsersCustomfieldsGetWithHttpInfo($baseRoleIds, $marker = null, $fieldIds = null, string $contentType = self::contentTypes['v1UsersCustomfieldsGet'][0])
    {
        $request = $this->v1UsersCustomfieldsGetRequest($baseRoleIds, $marker, $fieldIds, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SKY\School\Model\UserAdminCustomFieldCollection' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SKY\School\Model\UserAdminCustomFieldCollection' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SKY\School\Model\UserAdminCustomFieldCollection', []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = '\SKY\School\Model\UserAdminCustomFieldCollection';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SKY\School\Model\UserAdminCustomFieldCollection',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v1UsersCustomfieldsGetAsync
     *
     * Users custom fields list by base role(s)
     *
     * @param  string $baseRoleIds A comma delimited list of base role IDs to get users for. Example: &#x60;&#x60;&#x60;base_role_ids&#x3D;14,16&#x60;&#x60;&#x60; for Students and Parents. (required)
     * @param  int $marker Format - int32. The user&#39;s &#x60;&#x60;&#x60;id&#x60;&#x60;&#x60; to start at to return the next batch of data. Results will start with the next user in the result set. (optional)
     * @param  string $fieldIds A comma delimited list of field IDs to filter the result set down to. Only matching custom fields will be returned from that result set for all users in that set even if they don&#39;t have any data for the given &#x60;&#x60;&#x60;field_ids&#x60;&#x60;&#x60;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersCustomfieldsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1UsersCustomfieldsGetAsync($baseRoleIds, $marker = null, $fieldIds = null, string $contentType = self::contentTypes['v1UsersCustomfieldsGet'][0])
    {
        return $this->v1UsersCustomfieldsGetAsyncWithHttpInfo($baseRoleIds, $marker, $fieldIds, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v1UsersCustomfieldsGetAsyncWithHttpInfo
     *
     * Users custom fields list by base role(s)
     *
     * @param  string $baseRoleIds A comma delimited list of base role IDs to get users for. Example: &#x60;&#x60;&#x60;base_role_ids&#x3D;14,16&#x60;&#x60;&#x60; for Students and Parents. (required)
     * @param  int $marker Format - int32. The user&#39;s &#x60;&#x60;&#x60;id&#x60;&#x60;&#x60; to start at to return the next batch of data. Results will start with the next user in the result set. (optional)
     * @param  string $fieldIds A comma delimited list of field IDs to filter the result set down to. Only matching custom fields will be returned from that result set for all users in that set even if they don&#39;t have any data for the given &#x60;&#x60;&#x60;field_ids&#x60;&#x60;&#x60;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersCustomfieldsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1UsersCustomfieldsGetAsyncWithHttpInfo($baseRoleIds, $marker = null, $fieldIds = null, string $contentType = self::contentTypes['v1UsersCustomfieldsGet'][0])
    {
        $returnType = '\SKY\School\Model\UserAdminCustomFieldCollection';
        $request = $this->v1UsersCustomfieldsGetRequest($baseRoleIds, $marker, $fieldIds, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v1UsersCustomfieldsGet'
     *
     * @param  string $baseRoleIds A comma delimited list of base role IDs to get users for. Example: &#x60;&#x60;&#x60;base_role_ids&#x3D;14,16&#x60;&#x60;&#x60; for Students and Parents. (required)
     * @param  int $marker Format - int32. The user&#39;s &#x60;&#x60;&#x60;id&#x60;&#x60;&#x60; to start at to return the next batch of data. Results will start with the next user in the result set. (optional)
     * @param  string $fieldIds A comma delimited list of field IDs to filter the result set down to. Only matching custom fields will be returned from that result set for all users in that set even if they don&#39;t have any data for the given &#x60;&#x60;&#x60;field_ids&#x60;&#x60;&#x60;. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersCustomfieldsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v1UsersCustomfieldsGetRequest($baseRoleIds, $marker = null, $fieldIds = null, string $contentType = self::contentTypes['v1UsersCustomfieldsGet'][0])
    {

        // verify the required parameter 'baseRoleIds' is set
        if ($baseRoleIds === null || (is_array($baseRoleIds) && count($baseRoleIds) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $baseRoleIds when calling v1UsersCustomfieldsGet'
            );
        }




        $resourcePath = '/v1/users/customfields';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $baseRoleIds,
            'base_role_ids', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $marker,
            'marker', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fieldIds,
            'field_ids', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v1UsersEmergencycontactsChangedGet
     *
     * Users emergency contact changes
     *
     * @param  \DateTime $startDate Format - date-time (as date-time in RFC3339). The date to begin looking for changes. Use &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/ISO_8601\&quot; target&#x3D;\&quot;_blank\&quot;&gt;ISO-8601&lt;/a&gt; date format: 2022-04-16. (optional)
     * @param  int $marker Format - int32. The user&#39;s ID to start at to return the next batch of data. Results will start with the next user in the result set. (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersEmergencycontactsChangedGet'] to see the possible values for this operation
     *
     * @throws \SKY\School\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \SKY\School\Model\EmergencyContactChangeCollection
     */
    public function v1UsersEmergencycontactsChangedGet($startDate = null, $marker = 0, string $contentType = self::contentTypes['v1UsersEmergencycontactsChangedGet'][0])
    {
        [$response] = $this->v1UsersEmergencycontactsChangedGetWithHttpInfo($startDate, $marker, $contentType);
        return $response;
    }

    /**
     * Operation v1UsersEmergencycontactsChangedGetWithHttpInfo
     *
     * Users emergency contact changes
     *
     * @param  \DateTime $startDate Format - date-time (as date-time in RFC3339). The date to begin looking for changes. Use &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/ISO_8601\&quot; target&#x3D;\&quot;_blank\&quot;&gt;ISO-8601&lt;/a&gt; date format: 2022-04-16. (optional)
     * @param  int $marker Format - int32. The user&#39;s ID to start at to return the next batch of data. Results will start with the next user in the result set. (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersEmergencycontactsChangedGet'] to see the possible values for this operation
     *
     * @throws \SKY\School\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \SKY\School\Model\EmergencyContactChangeCollection, HTTP status code, HTTP response headers (array of strings)
     */
    public function v1UsersEmergencycontactsChangedGetWithHttpInfo($startDate = null, $marker = 0, string $contentType = self::contentTypes['v1UsersEmergencycontactsChangedGet'][0])
    {
        $request = $this->v1UsersEmergencycontactsChangedGetRequest($startDate, $marker, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SKY\School\Model\EmergencyContactChangeCollection' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SKY\School\Model\EmergencyContactChangeCollection' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SKY\School\Model\EmergencyContactChangeCollection', []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = '\SKY\School\Model\EmergencyContactChangeCollection';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SKY\School\Model\EmergencyContactChangeCollection',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v1UsersEmergencycontactsChangedGetAsync
     *
     * Users emergency contact changes
     *
     * @param  \DateTime $startDate Format - date-time (as date-time in RFC3339). The date to begin looking for changes. Use &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/ISO_8601\&quot; target&#x3D;\&quot;_blank\&quot;&gt;ISO-8601&lt;/a&gt; date format: 2022-04-16. (optional)
     * @param  int $marker Format - int32. The user&#39;s ID to start at to return the next batch of data. Results will start with the next user in the result set. (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersEmergencycontactsChangedGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1UsersEmergencycontactsChangedGetAsync($startDate = null, $marker = 0, string $contentType = self::contentTypes['v1UsersEmergencycontactsChangedGet'][0])
    {
        return $this->v1UsersEmergencycontactsChangedGetAsyncWithHttpInfo($startDate, $marker, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v1UsersEmergencycontactsChangedGetAsyncWithHttpInfo
     *
     * Users emergency contact changes
     *
     * @param  \DateTime $startDate Format - date-time (as date-time in RFC3339). The date to begin looking for changes. Use &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/ISO_8601\&quot; target&#x3D;\&quot;_blank\&quot;&gt;ISO-8601&lt;/a&gt; date format: 2022-04-16. (optional)
     * @param  int $marker Format - int32. The user&#39;s ID to start at to return the next batch of data. Results will start with the next user in the result set. (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersEmergencycontactsChangedGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1UsersEmergencycontactsChangedGetAsyncWithHttpInfo($startDate = null, $marker = 0, string $contentType = self::contentTypes['v1UsersEmergencycontactsChangedGet'][0])
    {
        $returnType = '\SKY\School\Model\EmergencyContactChangeCollection';
        $request = $this->v1UsersEmergencycontactsChangedGetRequest($startDate, $marker, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v1UsersEmergencycontactsChangedGet'
     *
     * @param  \DateTime $startDate Format - date-time (as date-time in RFC3339). The date to begin looking for changes. Use &lt;a href&#x3D;\&quot;https://en.wikipedia.org/wiki/ISO_8601\&quot; target&#x3D;\&quot;_blank\&quot;&gt;ISO-8601&lt;/a&gt; date format: 2022-04-16. (optional)
     * @param  int $marker Format - int32. The user&#39;s ID to start at to return the next batch of data. Results will start with the next user in the result set. (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersEmergencycontactsChangedGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v1UsersEmergencycontactsChangedGetRequest($startDate = null, $marker = 0, string $contentType = self::contentTypes['v1UsersEmergencycontactsChangedGet'][0])
    {




        $resourcePath = '/v1/users/emergencycontacts/changed';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $startDate,
            'start_date', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $marker,
            'marker', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v1UsersEnrollPost
     *
     * Users enrollment create
     *
     * @param  \SKY\School\Model\UserEnrollmentCreate $userEnrollmentCreate  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersEnrollPost'] to see the possible values for this operation
     *
     * @throws \SKY\School\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \SKY\School\Model\UserEnrollmentResponse
     */
    public function v1UsersEnrollPost($userEnrollmentCreate = null, string $contentType = self::contentTypes['v1UsersEnrollPost'][0])
    {
        [$response] = $this->v1UsersEnrollPostWithHttpInfo($userEnrollmentCreate, $contentType);
        return $response;
    }

    /**
     * Operation v1UsersEnrollPostWithHttpInfo
     *
     * Users enrollment create
     *
     * @param  \SKY\School\Model\UserEnrollmentCreate $userEnrollmentCreate  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersEnrollPost'] to see the possible values for this operation
     *
     * @throws \SKY\School\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \SKY\School\Model\UserEnrollmentResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function v1UsersEnrollPostWithHttpInfo($userEnrollmentCreate = null, string $contentType = self::contentTypes['v1UsersEnrollPost'][0])
    {
        $request = $this->v1UsersEnrollPostRequest($userEnrollmentCreate, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SKY\School\Model\UserEnrollmentResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SKY\School\Model\UserEnrollmentResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SKY\School\Model\UserEnrollmentResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = '\SKY\School\Model\UserEnrollmentResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SKY\School\Model\UserEnrollmentResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v1UsersEnrollPostAsync
     *
     * Users enrollment create
     *
     * @param  \SKY\School\Model\UserEnrollmentCreate $userEnrollmentCreate  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersEnrollPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1UsersEnrollPostAsync($userEnrollmentCreate = null, string $contentType = self::contentTypes['v1UsersEnrollPost'][0])
    {
        return $this->v1UsersEnrollPostAsyncWithHttpInfo($userEnrollmentCreate, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v1UsersEnrollPostAsyncWithHttpInfo
     *
     * Users enrollment create
     *
     * @param  \SKY\School\Model\UserEnrollmentCreate $userEnrollmentCreate  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersEnrollPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1UsersEnrollPostAsyncWithHttpInfo($userEnrollmentCreate = null, string $contentType = self::contentTypes['v1UsersEnrollPost'][0])
    {
        $returnType = '\SKY\School\Model\UserEnrollmentResponse';
        $request = $this->v1UsersEnrollPostRequest($userEnrollmentCreate, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v1UsersEnrollPost'
     *
     * @param  \SKY\School\Model\UserEnrollmentCreate $userEnrollmentCreate  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersEnrollPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v1UsersEnrollPostRequest($userEnrollmentCreate = null, string $contentType = self::contentTypes['v1UsersEnrollPost'][0])
    {



        $resourcePath = '/v1/users/enroll';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($userEnrollmentCreate)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($userEnrollmentCreate));
            } else {
                $httpBody = $userEnrollmentCreate;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v1UsersEnrollmentsGet
     *
     * Users enrollments by year
     *
     * @param  string $schoolYear The school year label to get enrollments for. The school year should be formatted like &#x60;&#x60;&#x60;2022-2023&#x60;&#x60;&#x60; (required)
     * @param  int $schoolLevelId Format - int32. The school level Id to return enrollments for. Optional. (optional)
     * @param  int $gradeLevelId Format - int32. The grade level Id to return enrollments for. Optional. (optional)
     * @param  int $limit Format - int32. The number of records to return.  Defaults to 1000. Maximum is 5000. (optional, default to 1000)
     * @param  int $offset Format - int32. The record to start the next collection on. Defaults to 0. (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersEnrollmentsGet'] to see the possible values for this operation
     *
     * @throws \SKY\School\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \SKY\School\Model\UserEnrollmentCollection
     */
    public function v1UsersEnrollmentsGet($schoolYear, $schoolLevelId = null, $gradeLevelId = null, $limit = 1000, $offset = 0, string $contentType = self::contentTypes['v1UsersEnrollmentsGet'][0])
    {
        [$response] = $this->v1UsersEnrollmentsGetWithHttpInfo($schoolYear, $schoolLevelId, $gradeLevelId, $limit, $offset, $contentType);
        return $response;
    }

    /**
     * Operation v1UsersEnrollmentsGetWithHttpInfo
     *
     * Users enrollments by year
     *
     * @param  string $schoolYear The school year label to get enrollments for. The school year should be formatted like &#x60;&#x60;&#x60;2022-2023&#x60;&#x60;&#x60; (required)
     * @param  int $schoolLevelId Format - int32. The school level Id to return enrollments for. Optional. (optional)
     * @param  int $gradeLevelId Format - int32. The grade level Id to return enrollments for. Optional. (optional)
     * @param  int $limit Format - int32. The number of records to return.  Defaults to 1000. Maximum is 5000. (optional, default to 1000)
     * @param  int $offset Format - int32. The record to start the next collection on. Defaults to 0. (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersEnrollmentsGet'] to see the possible values for this operation
     *
     * @throws \SKY\School\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \SKY\School\Model\UserEnrollmentCollection, HTTP status code, HTTP response headers (array of strings)
     */
    public function v1UsersEnrollmentsGetWithHttpInfo($schoolYear, $schoolLevelId = null, $gradeLevelId = null, $limit = 1000, $offset = 0, string $contentType = self::contentTypes['v1UsersEnrollmentsGet'][0])
    {
        $request = $this->v1UsersEnrollmentsGetRequest($schoolYear, $schoolLevelId, $gradeLevelId, $limit, $offset, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SKY\School\Model\UserEnrollmentCollection' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SKY\School\Model\UserEnrollmentCollection' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SKY\School\Model\UserEnrollmentCollection', []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = '\SKY\School\Model\UserEnrollmentCollection';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SKY\School\Model\UserEnrollmentCollection',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v1UsersEnrollmentsGetAsync
     *
     * Users enrollments by year
     *
     * @param  string $schoolYear The school year label to get enrollments for. The school year should be formatted like &#x60;&#x60;&#x60;2022-2023&#x60;&#x60;&#x60; (required)
     * @param  int $schoolLevelId Format - int32. The school level Id to return enrollments for. Optional. (optional)
     * @param  int $gradeLevelId Format - int32. The grade level Id to return enrollments for. Optional. (optional)
     * @param  int $limit Format - int32. The number of records to return.  Defaults to 1000. Maximum is 5000. (optional, default to 1000)
     * @param  int $offset Format - int32. The record to start the next collection on. Defaults to 0. (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersEnrollmentsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1UsersEnrollmentsGetAsync($schoolYear, $schoolLevelId = null, $gradeLevelId = null, $limit = 1000, $offset = 0, string $contentType = self::contentTypes['v1UsersEnrollmentsGet'][0])
    {
        return $this->v1UsersEnrollmentsGetAsyncWithHttpInfo($schoolYear, $schoolLevelId, $gradeLevelId, $limit, $offset, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v1UsersEnrollmentsGetAsyncWithHttpInfo
     *
     * Users enrollments by year
     *
     * @param  string $schoolYear The school year label to get enrollments for. The school year should be formatted like &#x60;&#x60;&#x60;2022-2023&#x60;&#x60;&#x60; (required)
     * @param  int $schoolLevelId Format - int32. The school level Id to return enrollments for. Optional. (optional)
     * @param  int $gradeLevelId Format - int32. The grade level Id to return enrollments for. Optional. (optional)
     * @param  int $limit Format - int32. The number of records to return.  Defaults to 1000. Maximum is 5000. (optional, default to 1000)
     * @param  int $offset Format - int32. The record to start the next collection on. Defaults to 0. (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersEnrollmentsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1UsersEnrollmentsGetAsyncWithHttpInfo($schoolYear, $schoolLevelId = null, $gradeLevelId = null, $limit = 1000, $offset = 0, string $contentType = self::contentTypes['v1UsersEnrollmentsGet'][0])
    {
        $returnType = '\SKY\School\Model\UserEnrollmentCollection';
        $request = $this->v1UsersEnrollmentsGetRequest($schoolYear, $schoolLevelId, $gradeLevelId, $limit, $offset, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v1UsersEnrollmentsGet'
     *
     * @param  string $schoolYear The school year label to get enrollments for. The school year should be formatted like &#x60;&#x60;&#x60;2022-2023&#x60;&#x60;&#x60; (required)
     * @param  int $schoolLevelId Format - int32. The school level Id to return enrollments for. Optional. (optional)
     * @param  int $gradeLevelId Format - int32. The grade level Id to return enrollments for. Optional. (optional)
     * @param  int $limit Format - int32. The number of records to return.  Defaults to 1000. Maximum is 5000. (optional, default to 1000)
     * @param  int $offset Format - int32. The record to start the next collection on. Defaults to 0. (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersEnrollmentsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v1UsersEnrollmentsGetRequest($schoolYear, $schoolLevelId = null, $gradeLevelId = null, $limit = 1000, $offset = 0, string $contentType = self::contentTypes['v1UsersEnrollmentsGet'][0])
    {

        // verify the required parameter 'schoolYear' is set
        if ($schoolYear === null || (is_array($schoolYear) && count($schoolYear) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $schoolYear when calling v1UsersEnrollmentsGet'
            );
        }






        $resourcePath = '/v1/users/enrollments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $schoolYear,
            'school_year', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $schoolLevelId,
            'school_level_id', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $gradeLevelId,
            'grade_level_id', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v1UsersExtendedByUserIdGet
     *
     * Users extended by user
     *
     * @param  int $userId Format - int32. The ID of the user. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersExtendedByUserIdGet'] to see the possible values for this operation
     *
     * @throws \SKY\School\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \SKY\School\Model\UserExtended
     */
    public function v1UsersExtendedByUserIdGet($userId, string $contentType = self::contentTypes['v1UsersExtendedByUserIdGet'][0])
    {
        [$response] = $this->v1UsersExtendedByUserIdGetWithHttpInfo($userId, $contentType);
        return $response;
    }

    /**
     * Operation v1UsersExtendedByUserIdGetWithHttpInfo
     *
     * Users extended by user
     *
     * @param  int $userId Format - int32. The ID of the user. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersExtendedByUserIdGet'] to see the possible values for this operation
     *
     * @throws \SKY\School\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \SKY\School\Model\UserExtended, HTTP status code, HTTP response headers (array of strings)
     */
    public function v1UsersExtendedByUserIdGetWithHttpInfo($userId, string $contentType = self::contentTypes['v1UsersExtendedByUserIdGet'][0])
    {
        $request = $this->v1UsersExtendedByUserIdGetRequest($userId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SKY\School\Model\UserExtended' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SKY\School\Model\UserExtended' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SKY\School\Model\UserExtended', []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = '\SKY\School\Model\UserExtended';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SKY\School\Model\UserExtended',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v1UsersExtendedByUserIdGetAsync
     *
     * Users extended by user
     *
     * @param  int $userId Format - int32. The ID of the user. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersExtendedByUserIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1UsersExtendedByUserIdGetAsync($userId, string $contentType = self::contentTypes['v1UsersExtendedByUserIdGet'][0])
    {
        return $this->v1UsersExtendedByUserIdGetAsyncWithHttpInfo($userId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v1UsersExtendedByUserIdGetAsyncWithHttpInfo
     *
     * Users extended by user
     *
     * @param  int $userId Format - int32. The ID of the user. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersExtendedByUserIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1UsersExtendedByUserIdGetAsyncWithHttpInfo($userId, string $contentType = self::contentTypes['v1UsersExtendedByUserIdGet'][0])
    {
        $returnType = '\SKY\School\Model\UserExtended';
        $request = $this->v1UsersExtendedByUserIdGetRequest($userId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v1UsersExtendedByUserIdGet'
     *
     * @param  int $userId Format - int32. The ID of the user. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersExtendedByUserIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v1UsersExtendedByUserIdGetRequest($userId, string $contentType = self::contentTypes['v1UsersExtendedByUserIdGet'][0])
    {

        // verify the required parameter 'userId' is set
        if ($userId === null || (is_array($userId) && count($userId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $userId when calling v1UsersExtendedByUserIdGet'
            );
        }


        $resourcePath = '/v1/users/extended/{user_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($userId !== null) {
            $resourcePath = str_replace(
                '{' . 'user_id' . '}',
                ObjectSerializer::toPathValue($userId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v1UsersExtendedGet
     *
     * Users extended by role(s)
     *
     * @param  string $baseRoleIds Comma delimited list of base role IDs to get users for. (required)
     * @param  int $marker Format - int32. The user&#39;s ID to start at to return the next batch of data. Results will start with the next user in the result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersExtendedGet'] to see the possible values for this operation
     *
     * @throws \SKY\School\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \SKY\School\Model\UserExtendedCollection
     */
    public function v1UsersExtendedGet($baseRoleIds, $marker = null, string $contentType = self::contentTypes['v1UsersExtendedGet'][0])
    {
        [$response] = $this->v1UsersExtendedGetWithHttpInfo($baseRoleIds, $marker, $contentType);
        return $response;
    }

    /**
     * Operation v1UsersExtendedGetWithHttpInfo
     *
     * Users extended by role(s)
     *
     * @param  string $baseRoleIds Comma delimited list of base role IDs to get users for. (required)
     * @param  int $marker Format - int32. The user&#39;s ID to start at to return the next batch of data. Results will start with the next user in the result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersExtendedGet'] to see the possible values for this operation
     *
     * @throws \SKY\School\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \SKY\School\Model\UserExtendedCollection, HTTP status code, HTTP response headers (array of strings)
     */
    public function v1UsersExtendedGetWithHttpInfo($baseRoleIds, $marker = null, string $contentType = self::contentTypes['v1UsersExtendedGet'][0])
    {
        $request = $this->v1UsersExtendedGetRequest($baseRoleIds, $marker, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SKY\School\Model\UserExtendedCollection' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SKY\School\Model\UserExtendedCollection' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SKY\School\Model\UserExtendedCollection', []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = '\SKY\School\Model\UserExtendedCollection';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SKY\School\Model\UserExtendedCollection',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v1UsersExtendedGetAsync
     *
     * Users extended by role(s)
     *
     * @param  string $baseRoleIds Comma delimited list of base role IDs to get users for. (required)
     * @param  int $marker Format - int32. The user&#39;s ID to start at to return the next batch of data. Results will start with the next user in the result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersExtendedGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1UsersExtendedGetAsync($baseRoleIds, $marker = null, string $contentType = self::contentTypes['v1UsersExtendedGet'][0])
    {
        return $this->v1UsersExtendedGetAsyncWithHttpInfo($baseRoleIds, $marker, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v1UsersExtendedGetAsyncWithHttpInfo
     *
     * Users extended by role(s)
     *
     * @param  string $baseRoleIds Comma delimited list of base role IDs to get users for. (required)
     * @param  int $marker Format - int32. The user&#39;s ID to start at to return the next batch of data. Results will start with the next user in the result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersExtendedGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1UsersExtendedGetAsyncWithHttpInfo($baseRoleIds, $marker = null, string $contentType = self::contentTypes['v1UsersExtendedGet'][0])
    {
        $returnType = '\SKY\School\Model\UserExtendedCollection';
        $request = $this->v1UsersExtendedGetRequest($baseRoleIds, $marker, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v1UsersExtendedGet'
     *
     * @param  string $baseRoleIds Comma delimited list of base role IDs to get users for. (required)
     * @param  int $marker Format - int32. The user&#39;s ID to start at to return the next batch of data. Results will start with the next user in the result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersExtendedGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v1UsersExtendedGetRequest($baseRoleIds, $marker = null, string $contentType = self::contentTypes['v1UsersExtendedGet'][0])
    {

        // verify the required parameter 'baseRoleIds' is set
        if ($baseRoleIds === null || (is_array($baseRoleIds) && count($baseRoleIds) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $baseRoleIds when calling v1UsersExtendedGet'
            );
        }



        $resourcePath = '/v1/users/extended';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $baseRoleIds,
            'base_role_ids', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $marker,
            'marker', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v1UsersGendertypesGet
     *
     * Users gender types
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersGendertypesGet'] to see the possible values for this operation
     *
     * @throws \SKY\School\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \SKY\School\Model\GenderTypeCollection
     */
    public function v1UsersGendertypesGet(string $contentType = self::contentTypes['v1UsersGendertypesGet'][0])
    {
        [$response] = $this->v1UsersGendertypesGetWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation v1UsersGendertypesGetWithHttpInfo
     *
     * Users gender types
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersGendertypesGet'] to see the possible values for this operation
     *
     * @throws \SKY\School\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \SKY\School\Model\GenderTypeCollection, HTTP status code, HTTP response headers (array of strings)
     */
    public function v1UsersGendertypesGetWithHttpInfo(string $contentType = self::contentTypes['v1UsersGendertypesGet'][0])
    {
        $request = $this->v1UsersGendertypesGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SKY\School\Model\GenderTypeCollection' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SKY\School\Model\GenderTypeCollection' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SKY\School\Model\GenderTypeCollection', []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = '\SKY\School\Model\GenderTypeCollection';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SKY\School\Model\GenderTypeCollection',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v1UsersGendertypesGetAsync
     *
     * Users gender types
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersGendertypesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1UsersGendertypesGetAsync(string $contentType = self::contentTypes['v1UsersGendertypesGet'][0])
    {
        return $this->v1UsersGendertypesGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v1UsersGendertypesGetAsyncWithHttpInfo
     *
     * Users gender types
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersGendertypesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1UsersGendertypesGetAsyncWithHttpInfo(string $contentType = self::contentTypes['v1UsersGendertypesGet'][0])
    {
        $returnType = '\SKY\School\Model\GenderTypeCollection';
        $request = $this->v1UsersGendertypesGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v1UsersGendertypesGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersGendertypesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v1UsersGendertypesGetRequest(string $contentType = self::contentTypes['v1UsersGendertypesGet'][0])
    {


        $resourcePath = '/v1/users/gendertypes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v1UsersMeGet
     *
     * Users Get Me
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersMeGet'] to see the possible values for this operation
     *
     * @throws \SKY\School\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \SKY\School\Model\UserMe
     */
    public function v1UsersMeGet(string $contentType = self::contentTypes['v1UsersMeGet'][0])
    {
        [$response] = $this->v1UsersMeGetWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation v1UsersMeGetWithHttpInfo
     *
     * Users Get Me
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersMeGet'] to see the possible values for this operation
     *
     * @throws \SKY\School\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \SKY\School\Model\UserMe, HTTP status code, HTTP response headers (array of strings)
     */
    public function v1UsersMeGetWithHttpInfo(string $contentType = self::contentTypes['v1UsersMeGet'][0])
    {
        $request = $this->v1UsersMeGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SKY\School\Model\UserMe' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SKY\School\Model\UserMe' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SKY\School\Model\UserMe', []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = '\SKY\School\Model\UserMe';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SKY\School\Model\UserMe',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v1UsersMeGetAsync
     *
     * Users Get Me
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersMeGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1UsersMeGetAsync(string $contentType = self::contentTypes['v1UsersMeGet'][0])
    {
        return $this->v1UsersMeGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v1UsersMeGetAsyncWithHttpInfo
     *
     * Users Get Me
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersMeGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1UsersMeGetAsyncWithHttpInfo(string $contentType = self::contentTypes['v1UsersMeGet'][0])
    {
        $returnType = '\SKY\School\Model\UserMe';
        $request = $this->v1UsersMeGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v1UsersMeGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersMeGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v1UsersMeGetRequest(string $contentType = self::contentTypes['v1UsersMeGet'][0])
    {


        $resourcePath = '/v1/users/me';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v1UsersPatch
     *
     * User update
     *
     * @param  \SKY\School\Model\UserEdit $userEdit User information to be updated (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersPatch'] to see the possible values for this operation
     *
     * @throws \SKY\School\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return int
     */
    public function v1UsersPatch($userEdit = null, string $contentType = self::contentTypes['v1UsersPatch'][0])
    {
        [$response] = $this->v1UsersPatchWithHttpInfo($userEdit, $contentType);
        return $response;
    }

    /**
     * Operation v1UsersPatchWithHttpInfo
     *
     * User update
     *
     * @param  \SKY\School\Model\UserEdit $userEdit User information to be updated (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersPatch'] to see the possible values for this operation
     *
     * @throws \SKY\School\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function v1UsersPatchWithHttpInfo($userEdit = null, string $contentType = self::contentTypes['v1UsersPatch'][0])
    {
        $request = $this->v1UsersPatchRequest($userEdit, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('int' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('int' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = 'int';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v1UsersPatchAsync
     *
     * User update
     *
     * @param  \SKY\School\Model\UserEdit $userEdit User information to be updated (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersPatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1UsersPatchAsync($userEdit = null, string $contentType = self::contentTypes['v1UsersPatch'][0])
    {
        return $this->v1UsersPatchAsyncWithHttpInfo($userEdit, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v1UsersPatchAsyncWithHttpInfo
     *
     * User update
     *
     * @param  \SKY\School\Model\UserEdit $userEdit User information to be updated (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersPatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1UsersPatchAsyncWithHttpInfo($userEdit = null, string $contentType = self::contentTypes['v1UsersPatch'][0])
    {
        $returnType = 'int';
        $request = $this->v1UsersPatchRequest($userEdit, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v1UsersPatch'
     *
     * @param  \SKY\School\Model\UserEdit $userEdit User information to be updated (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersPatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v1UsersPatchRequest($userEdit = null, string $contentType = self::contentTypes['v1UsersPatch'][0])
    {



        $resourcePath = '/v1/users';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($userEdit)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($userEdit));
            } else {
                $httpBody = $userEdit;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v1UsersPhonetypesGet
     *
     * Users phone types
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersPhonetypesGet'] to see the possible values for this operation
     *
     * @throws \SKY\School\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \SKY\School\Model\PhoneTypeCollection
     */
    public function v1UsersPhonetypesGet(string $contentType = self::contentTypes['v1UsersPhonetypesGet'][0])
    {
        [$response] = $this->v1UsersPhonetypesGetWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation v1UsersPhonetypesGetWithHttpInfo
     *
     * Users phone types
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersPhonetypesGet'] to see the possible values for this operation
     *
     * @throws \SKY\School\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \SKY\School\Model\PhoneTypeCollection, HTTP status code, HTTP response headers (array of strings)
     */
    public function v1UsersPhonetypesGetWithHttpInfo(string $contentType = self::contentTypes['v1UsersPhonetypesGet'][0])
    {
        $request = $this->v1UsersPhonetypesGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SKY\School\Model\PhoneTypeCollection' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SKY\School\Model\PhoneTypeCollection' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SKY\School\Model\PhoneTypeCollection', []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = '\SKY\School\Model\PhoneTypeCollection';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SKY\School\Model\PhoneTypeCollection',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v1UsersPhonetypesGetAsync
     *
     * Users phone types
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersPhonetypesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1UsersPhonetypesGetAsync(string $contentType = self::contentTypes['v1UsersPhonetypesGet'][0])
    {
        return $this->v1UsersPhonetypesGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v1UsersPhonetypesGetAsyncWithHttpInfo
     *
     * Users phone types
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersPhonetypesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1UsersPhonetypesGetAsyncWithHttpInfo(string $contentType = self::contentTypes['v1UsersPhonetypesGet'][0])
    {
        $returnType = '\SKY\School\Model\PhoneTypeCollection';
        $request = $this->v1UsersPhonetypesGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v1UsersPhonetypesGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersPhonetypesGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v1UsersPhonetypesGetRequest(string $contentType = self::contentTypes['v1UsersPhonetypesGet'][0])
    {


        $resourcePath = '/v1/users/phonetypes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v1UsersPost
     *
     * User create
     *
     * @param  \SKY\School\Model\UserAdd $userAdd The user to be created (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersPost'] to see the possible values for this operation
     *
     * @throws \SKY\School\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return int
     */
    public function v1UsersPost($userAdd = null, string $contentType = self::contentTypes['v1UsersPost'][0])
    {
        [$response] = $this->v1UsersPostWithHttpInfo($userAdd, $contentType);
        return $response;
    }

    /**
     * Operation v1UsersPostWithHttpInfo
     *
     * User create
     *
     * @param  \SKY\School\Model\UserAdd $userAdd The user to be created (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersPost'] to see the possible values for this operation
     *
     * @throws \SKY\School\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function v1UsersPostWithHttpInfo($userAdd = null, string $contentType = self::contentTypes['v1UsersPost'][0])
    {
        $request = $this->v1UsersPostRequest($userAdd, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('int' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('int' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = 'int';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v1UsersPostAsync
     *
     * User create
     *
     * @param  \SKY\School\Model\UserAdd $userAdd The user to be created (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1UsersPostAsync($userAdd = null, string $contentType = self::contentTypes['v1UsersPost'][0])
    {
        return $this->v1UsersPostAsyncWithHttpInfo($userAdd, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v1UsersPostAsyncWithHttpInfo
     *
     * User create
     *
     * @param  \SKY\School\Model\UserAdd $userAdd The user to be created (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1UsersPostAsyncWithHttpInfo($userAdd = null, string $contentType = self::contentTypes['v1UsersPost'][0])
    {
        $returnType = 'int';
        $request = $this->v1UsersPostRequest($userAdd, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v1UsersPost'
     *
     * @param  \SKY\School\Model\UserAdd $userAdd The user to be created (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1UsersPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v1UsersPostRequest($userAdd = null, string $contentType = self::contentTypes['v1UsersPost'][0])
    {



        $resourcePath = '/v1/users';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($userAdd)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($userAdd));
            } else {
                $httpBody = $userAdd;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v1usersget
     *
     * Users by role(s)
     *
     * @param  string $roles Comma delimited list of role IDs to get users for. (required)
     * @param  string $firstName Filter results by first name. (optional)
     * @param  string $lastName Filter results by last name. (optional)
     * @param  string $email Filter results by e-mail. (optional)
     * @param  string $maidenName Filter results by maiden name. (optional)
     * @param  string $gradYear The beginning date in a school year (ex. 2017). (optional)
     * @param  string $endGradYear The end date in a school year (ex. 2018). Enter a grad_year and end_grad_year to find matching results in the date range. (optional)
     * @param  int $marker Format - int32. The record number start at to return the next batch of data. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1usersget'] to see the possible values for this operation
     *
     * @throws \SKY\School\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \SKY\School\Model\UserReadCollection
     */
    public function v1usersget($roles, $firstName = null, $lastName = null, $email = null, $maidenName = null, $gradYear = null, $endGradYear = null, $marker = null, string $contentType = self::contentTypes['v1usersget'][0])
    {
        [$response] = $this->v1usersgetWithHttpInfo($roles, $firstName, $lastName, $email, $maidenName, $gradYear, $endGradYear, $marker, $contentType);
        return $response;
    }

    /**
     * Operation v1usersgetWithHttpInfo
     *
     * Users by role(s)
     *
     * @param  string $roles Comma delimited list of role IDs to get users for. (required)
     * @param  string $firstName Filter results by first name. (optional)
     * @param  string $lastName Filter results by last name. (optional)
     * @param  string $email Filter results by e-mail. (optional)
     * @param  string $maidenName Filter results by maiden name. (optional)
     * @param  string $gradYear The beginning date in a school year (ex. 2017). (optional)
     * @param  string $endGradYear The end date in a school year (ex. 2018). Enter a grad_year and end_grad_year to find matching results in the date range. (optional)
     * @param  int $marker Format - int32. The record number start at to return the next batch of data. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1usersget'] to see the possible values for this operation
     *
     * @throws \SKY\School\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \SKY\School\Model\UserReadCollection, HTTP status code, HTTP response headers (array of strings)
     */
    public function v1usersgetWithHttpInfo($roles, $firstName = null, $lastName = null, $email = null, $maidenName = null, $gradYear = null, $endGradYear = null, $marker = null, string $contentType = self::contentTypes['v1usersget'][0])
    {
        $request = $this->v1usersgetRequest($roles, $firstName, $lastName, $email, $maidenName, $gradYear, $endGradYear, $marker, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\SKY\School\Model\UserReadCollection' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SKY\School\Model\UserReadCollection' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SKY\School\Model\UserReadCollection', []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
            }

            $returnType = '\SKY\School\Model\UserReadCollection';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders(),
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SKY\School\Model\UserReadCollection',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v1usersgetAsync
     *
     * Users by role(s)
     *
     * @param  string $roles Comma delimited list of role IDs to get users for. (required)
     * @param  string $firstName Filter results by first name. (optional)
     * @param  string $lastName Filter results by last name. (optional)
     * @param  string $email Filter results by e-mail. (optional)
     * @param  string $maidenName Filter results by maiden name. (optional)
     * @param  string $gradYear The beginning date in a school year (ex. 2017). (optional)
     * @param  string $endGradYear The end date in a school year (ex. 2018). Enter a grad_year and end_grad_year to find matching results in the date range. (optional)
     * @param  int $marker Format - int32. The record number start at to return the next batch of data. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1usersget'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1usersgetAsync($roles, $firstName = null, $lastName = null, $email = null, $maidenName = null, $gradYear = null, $endGradYear = null, $marker = null, string $contentType = self::contentTypes['v1usersget'][0])
    {
        return $this->v1usersgetAsyncWithHttpInfo($roles, $firstName, $lastName, $email, $maidenName, $gradYear, $endGradYear, $marker, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v1usersgetAsyncWithHttpInfo
     *
     * Users by role(s)
     *
     * @param  string $roles Comma delimited list of role IDs to get users for. (required)
     * @param  string $firstName Filter results by first name. (optional)
     * @param  string $lastName Filter results by last name. (optional)
     * @param  string $email Filter results by e-mail. (optional)
     * @param  string $maidenName Filter results by maiden name. (optional)
     * @param  string $gradYear The beginning date in a school year (ex. 2017). (optional)
     * @param  string $endGradYear The end date in a school year (ex. 2018). Enter a grad_year and end_grad_year to find matching results in the date range. (optional)
     * @param  int $marker Format - int32. The record number start at to return the next batch of data. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1usersget'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1usersgetAsyncWithHttpInfo($roles, $firstName = null, $lastName = null, $email = null, $maidenName = null, $gradYear = null, $endGradYear = null, $marker = null, string $contentType = self::contentTypes['v1usersget'][0])
    {
        $returnType = '\SKY\School\Model\UserReadCollection';
        $request = $this->v1usersgetRequest($roles, $firstName, $lastName, $email, $maidenName, $gradYear, $endGradYear, $marker, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v1usersget'
     *
     * @param  string $roles Comma delimited list of role IDs to get users for. (required)
     * @param  string $firstName Filter results by first name. (optional)
     * @param  string $lastName Filter results by last name. (optional)
     * @param  string $email Filter results by e-mail. (optional)
     * @param  string $maidenName Filter results by maiden name. (optional)
     * @param  string $gradYear The beginning date in a school year (ex. 2017). (optional)
     * @param  string $endGradYear The end date in a school year (ex. 2018). Enter a grad_year and end_grad_year to find matching results in the date range. (optional)
     * @param  int $marker Format - int32. The record number start at to return the next batch of data. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v1usersget'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v1usersgetRequest($roles, $firstName = null, $lastName = null, $email = null, $maidenName = null, $gradYear = null, $endGradYear = null, $marker = null, string $contentType = self::contentTypes['v1usersget'][0])
    {

        // verify the required parameter 'roles' is set
        if ($roles === null || (is_array($roles) && count($roles) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $roles when calling v1usersget'
            );
        }









        $resourcePath = '/v1/users';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $roles,
            'roles', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $firstName,
            'first_name', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $lastName,
            'last_name', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $email,
            'email', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $maidenName,
            'maiden_name', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $gradYear,
            'grad_year', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $endGradYear,
            'end_grad_year', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $marker,
            'marker', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('subscription-key');
        if ($apiKey !== null) {
            $queryParams['subscription-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Bb-Api-Subscription-Key');
        if ($apiKey !== null) {
            $headers['Bb-Api-Subscription-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
